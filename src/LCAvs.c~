/*Functions for the fitting of Latent Class Analysis models using MCMC
	methods. Two implementations of the model are included in the Bayesian
	formulation: collapsed and not collapsed.
	
	Author:	Jason Wyse,
			School of Computer Science and Statistics,
			Lloyd Institute,
			Trinity College,
			Dublin 2,
			Ireland.
			mailto: wyseja@tcd.ie
			
	Last modification of this code: Wed 21 May 2014 15:55:53 IST  */

#include "LCAvs.h"

void mixmod_warning(int warning)
/*warning handler*/
{
	#define NumWarningMsgs 3

  static const char *warningmsg[NumWarningMsgs] = {"The EM algorithm reached the maximum number of steps when initializing. Only a lower tolerance may be obtainable.",
  	"Computation of the marginal likelihood for a cluster returned a nan",
  	"There is a counting bug in metropolis move 1"};

  printf("\n***Warning*** \t Reason: %s\n\n",warningmsg[warning]);
  return;

}

struct mix_mod *allocate_mixmod(int datasize, int datadimension, int maxgroups, int initgroups,double *prior_hparams,int *ncat, int collapsed)
/*this function allocates and returns a pointer to a mixmod structure...*/
{

	int i,j,k;
	FILE *fp;
	
	struct mix_mod *mixmod = (struct mix_mod *)malloc(sizeof(struct mix_mod));

	mixmod->maxgroups = maxgroups;
	mixmod->G = initgroups;
	mixmod->n = datasize;
	mixmod->d = datadimension;
	mixmod->collapsed = collapsed;
	
	mixmod->Y = calloc(datadimension,sizeof(int *));
	for(i=0;i<datadimension;i++){
		mixmod->Y[i] = calloc(datasize,sizeof(int));
	}
	
	mixmod->Yobs = calloc(datasize,sizeof(int *));
	for(i=0;i<datasize;i++){
		mixmod->Yobs[i] = calloc(datadimension,sizeof(int *));
	}
	
	mixmod->z = calloc(datasize,sizeof(int));
	
	mixmod->ncat = calloc(datadimension,sizeof(int));
	for(i=0;i<datadimension;i++){
		mixmod->ncat[i] = ncat[i];
	}
	
	mixmod->varindicator = calloc(datadimension,sizeof(int));
	
	/*allocate this memory-- only initialize what is needed for initial conditions*/
	mixmod->components = (struct component **)malloc(sizeof(struct component *)*maxgroups);

	for(i=0;i<maxgroups;i++){
		mixmod->components[i] = (struct component *)malloc(sizeof(struct component));
	}
	
	mixmod->undiscriminating = (struct component *)malloc(sizeof(struct component));
	allocate_component(mixmod->undiscriminating,mixmod);
	mixmod->undiscriminating->n_g = mixmod->n; /*there is always n elements in here as these variables
																	do not define a clustering...*/

	
	/*allocate whereis*/
	
	mixmod->whereis = calloc(maxgroups,sizeof(int));
	for(i=0;i<maxgroups;i++)
		mixmod->whereis[i] = -1;
	
	/*allocate for the initial number of components*/
	for(i=0;i<initgroups;i++){
		allocate_component(mixmod->components[i],mixmod);
		mixmod->components[i]->in_use = TRUE;
		mixmod->components[i]->n_g = 0;
	}
	for(i=initgroups;i<maxgroups;i++){
		allocate_component(mixmod->components[i],mixmod);
		mixmod->components[i]->in_use = FALSE;
		mixmod->components[i]->n_g = 0;
	}

	
	/*there will be two hparameters in the default model:
		alpha: dirichlet prior on weights symmetric
		beta: dirichlet prior for within component membership probs
		*/
	
	mixmod->alpha = prior_hparams[0];
	mixmod->beta = prior_hparams[1];

	mixmod->log_prior_G = calloc(maxgroups+1,sizeof(double));
	
	/*assign space for the lookup table for a values*/
	
	mixmod->table_a = calloc(datasize,sizeof(double));
	
	if(!mixmod->collapsed) mixmod->weights = calloc(mixmod->G,sizeof(double));
	
	return(mixmod);

}

void free_mixmod(struct mix_mod *mixmod)
/*frees the memory used by mixmod object*/
{
	int n = mixmod->n,d = mixmod->d, G = mixmod->G,i,j,k;
	
	/*free up components*/
	for(k=0;k<mixmod->maxgroups;k++){
		free_component(mixmod->components[k],mixmod);
		free(mixmod->components[k]);
	}
	free(mixmod->components);
	
	free_component(mixmod->undiscriminating,mixmod);
	free(mixmod->undiscriminating);
	
	/*free wehreis*/
	free(mixmod->whereis);
	
	/*free data*/
	for(i=0;i<d;i++){
		free(mixmod->Y[i]);
	}
	free(mixmod->Y);
	
	for(i=0;i<n;i++){
		free(mixmod->Yobs[i]);
	}
	free(mixmod->Yobs);
	
	/*free others*/
	free(mixmod->z);
	
	free(mixmod->ncat);
	
	free(mixmod->varindicator);
	
	free(mixmod->log_prior_G);
	
	/*free table*/
	free(mixmod->table_a);
	
	if(!mixmod->collapsed) free(mixmod->weights);
	
	free(mixmod);
	
	return;
}

void allocate_component(struct component *component,struct mix_mod *mixmod)
{
	/*allocate memory for a component*/
	int j;
	
	component->N = calloc(mixmod->d,sizeof(int *));
	
	for(j=0;j<mixmod->d;j++){
		component->N[j] = calloc(mixmod->ncat[j],sizeof(int));
	}
	
	if(!mixmod->collapsed)
	{
		component->prob_variables = calloc(mixmod->d,sizeof(double *));
		for(j=0;j<mixmod->d;j++){
			component->prob_variables[j] = calloc(mixmod->ncat[j],sizeof(double));
		}
	}
	
	return;
}

void free_component(struct component *component,struct mix_mod *mixmod)
{
	
	int j;
	
	for(j=0;j<mixmod->d;j++){
		free(component->N[j]);
	}
	free(component->N);
	
	if(!mixmod->collapsed)
	{
		for(j=0;j<mixmod->d;j++){
			free(component->prob_variables[j]);
		}
		free(component->prob_variables);
	}
	
	return;
	
}

void copy_component(struct component *component_original,struct component *component_target,struct mix_mod *mixmod)
/*copy the contents of the first argument into the second component argument*/
{

	int i,j;
	
	component_target->n_g = component_original->n_g;
	for(i=0;i<mixmod->d;i++){
		for(j=0;j<mixmod->ncat[i];j++){
			component_target->N[i][j] = component_original->N[i][j];
		}
	}

	component_target->log_prob = component_original->log_prob;
	
	return;

}

void allocate_results(struct results *results,int iterations,int burn_in,int thin_by,int len,int d,int writeToFile)
/*allocates space to store post burn-in iterations*/
{
	
	int i,N = (iterations-burn_in)/thin_by;
	
	if(!writeToFile)
	{
	
		/*results->memberships = calloc(N,sizeof(int *));
		for(i=0;i<N;i++){
			results->memberships[i] = calloc(len,sizeof(int));
		}*/
	
		//results->MAP_memberships = calloc(len,sizeof(int));
	
		/*results->variable_indicator = calloc(N,sizeof(int *));
		for(i=0;i<N;i++){
			results->variable_indicator[i] = calloc(d,sizeof(int));
		}
	
		results->log_posterior = calloc(iterations,sizeof(double));*/
	}
	
	results->ngroups = calloc(N,sizeof(int));
	results->variable_prob_inclusion = calloc(d,sizeof(double));
	
	results->proposed_m1 = 0;
	results->accepted_m1 = 0;
	results->proposed_m2 = 0;
	results->accepted_m2 = 0;
	results->proposed_m3 = 0;
	results->accepted_m3 = 0;
	results->proposed_eject = 0;
	results->accepted_eject = 0;
	results->proposed_absorb = 0;
	results->accepted_absorb = 0;
	results->proposed_add_variable = 0;
	results->accepted_add_variable = 0;
	results->proposed_remove_variable = 0;
	results->accepted_remove_variable = 0;
	results->proposed_include_exclude_variable = 0;
	results->accepted_include_exclude_variable = 0;
	
	return;
}

void free_results(struct results *results,int iterations,int burn_in,int thin_by,int writeToFile)
{
	int i,N = (iterations-burn_in)/thin_by;
	
	if(!writeToFile)
	{
	
		/*for(i=0;i<N;i++){
			free(results->memberships[i]);
			free(results->variable_indicator[i]);
		}
		free(results->memberships);
		free(results->variable_indicator);
	
		free(results->MAP_memberships);
	
		free(results->log_posterior);*/
	
	}
	free(results->ngroups);
	free(results->variable_prob_inclusion);
	
	free(results);
	
	return; 
}

void allocate_results_x2(struct results *results,int iterations,int burn_in,int thin_by,int len,int d,int writeToFile)
/*allocates space to store post burn-in iterations*/
{
	
	int i,N = (iterations-burn_in)/thin_by;
	
	if(!writeToFile)
	{
	
		results->memberships = calloc(N,sizeof(int *));
		for(i=0;i<N;i++){
			results->memberships[i] = calloc(len,sizeof(int));
		}
	
		results->MAP_memberships = calloc(len,sizeof(int));
	
		results->variable_indicator = calloc(N,sizeof(int *));
		for(i=0;i<N;i++){
			results->variable_indicator[i] = calloc(d,sizeof(int));
		}
	
		results->log_posterior = calloc(iterations,sizeof(double));
	}
	
	results->ngroups = calloc(N,sizeof(int));
	results->variable_prob_inclusion = calloc(d,sizeof(double));
	
	results->proposed_m1 = 0;
	results->accepted_m1 = 0;
	results->proposed_m2 = 0;
	results->accepted_m2 = 0;
	results->proposed_m3 = 0;
	results->accepted_m3 = 0;
	results->proposed_eject = 0;
	results->accepted_eject = 0;
	results->proposed_absorb = 0;
	results->accepted_absorb = 0;
	results->proposed_add_variable = 0;
	results->accepted_add_variable = 0;
	results->proposed_remove_variable = 0;
	results->accepted_remove_variable = 0;
	results->proposed_include_exclude_variable = 0;
	results->accepted_include_exclude_variable = 0;
	
	return;
}

void free_results_x2(struct results *results,int iterations,int burn_in,int thin_by,int writeToFile)
{
	int i,N = (iterations-burn_in)/thin_by;
	
	if(!writeToFile)
	{
	
		for(i=0;i<N;i++){
			free(results->memberships[i]);
			free(results->variable_indicator[i]);
		}
		free(results->memberships);
		free(results->variable_indicator);
	
		free(results->MAP_memberships);
	
		free(results->log_posterior);
	
	}
	free(results->ngroups);
	free(results->variable_prob_inclusion);
	
	free(results);
	
	return; 
}




void set_prior_on_number_of_components(struct mix_mod *mixmod,int type)
{

	int i;
	
	switch(type)
	{
	
		case RICHARDSON_AND_GREEN:
		
			for(i=0;i<mixmod->maxgroups+1;i++){
				mixmod->log_prior_G[i] = 0.;
			}
		
		break;
		
		case NOBILE_AND_FEARNSIDE:
		
			for(i=1;i<mixmod->maxgroups+1;i++){
				mixmod->log_prior_G[i] = -lgamma((double)i + 1.);
			}
		
		break;
	
	}
	

	return;

}


int initialize_simple(struct mix_mod *mixmod,int numgroups)
/*gives a very simple initialization of the model by just dumping the
	first n/G observations in the first group, second n/G in second group...*/
{
	int i,j,jj,k,G=numgroups,d=mixmod->d,n=mixmod->n;

	int m = n/G; /*gives the number of segments*/
	for(k=0;k<G-1;k++){
	
		for(i=0;i<d;i++){
			mixmod->varindicator[i] = 1;
			for(j=0;j<mixmod->ncat[i];j++)
				mixmod->components[k]->N[i][j] = 0;
		}
	
		/*cycle through appropriate data*/
		for(i=k*m;i<(k+1)*m;i++){
			mixmod->z[i] = k;
			mixmod->components[k]->n_g = m;
			for(j=0;j<d;j++){ 
				mixmod->components[k]->N[j][ mixmod->Y[j][i] ] += 1; 
			}
		}
	}
	
	/*special case for last group*/

	for(i=0;i<d;i++){
		for(j=0;j<mixmod->ncat[i];j++)
			mixmod->components[G-1]->N[i][j] = 0;
	}
	
	for(i=(G-1)*m;i<n;i++){
		mixmod->z[i] = G-1;
		mixmod->components[G-1]->n_g = n-(G-1)*m;
		for(j=0;j<d;j++){
			mixmod->components[G-1]->N[j][ mixmod->Y[j][i] ] += 1;
		}
	}

	
	/*compute the log_prob for each of the components*/
	for(k=0;k<G;k++){
		recompute_marginal_likelihood_component(mixmod->components[k],mixmod);
	}	
	
	for(i=0;i<n;i++){
		for(j=0;j<d;j++){
			mixmod->undiscriminating->N[j][ mixmod->Y[j][i] ] += 1;
		}
	} 
	
	recompute_marginal_likelihood_undiscriminating_variables(mixmod->undiscriminating,mixmod);

	for(k=0;k<G;k++){
		mixmod->whereis[k] = k;
	}
	
	if(FALSE)
	{
		//initialize the weights and vectors of probabilities also
		double s = 0.;
		
		
	
	}

	return(TRUE);
}


double get_max(double *x,int len)
/*returns maximum of a vector x*/
{
	int i;
	double max=x[0];
	
	if(len > 1){
		for(i=1;i<len;i++){
			if(x[i]>max)
				max = x[i];
		}
	
	}
	return(max);
}

double get_min(double *x,int len)
/*returns maximum of a vector x*/
{
	int i;
	double min=x[0];
	
	if(len > 1){
		for(i=1;i<len;i++){
			if(x[i]<min)
				min = x[i];
		}
	
	}
	return(min);
}

int get_imax(int *x,int len)
/*returns maximum of a vector x*/
{
	int i;
	int max=x[0];
	
	if(len > 1){
		for(i=1;i<len;i++){
			if(x[i]>max)
				max = x[i];
		}
	
	}
	return(max);
}


int sample_discrete(double *weights,int len,gsl_rng *r)
{
	/*sample once from a multinomial distribution with weights*/
	
	int i=0;
	unsigned int *n;
	
	n = calloc(len,sizeof(unsigned int));
	
	gsl_ran_multinomial(r,(unsigned int)len,(size_t)1,weights,n);
	
	while(n[i] == 0){
		i += 1;
	}
	
	free(n);
	
	return(i);	

}

int get_ind_max(double *x,int len)
/*returns index of the maximum of vector x
  cases with ties: lowest index from 0 returned*/
{
	double max;
	int i=0;
	
	max = get_max(x,len);
	
	while(1){	
		if(x[i]==max) break;
		i++;
	}
	
	return i;
}


int update_allocations_with_gibbs(struct mix_mod *mixmod,gsl_rng *r)
{

	//printf("\nwithin Gibbs...\n");

	int i,ii,ind,j,k,g,g_prime,ig,ig_prime,d=mixmod->d,position,G=mixmod->G,*order,*x;
	double *probs,max,z;
	
	probs = calloc(G,sizeof(double));
	order = calloc(mixmod->n,sizeof(int));
	
	/*cycle through the elements in turn... maybe randomize order?*/
	
	/*randomize the order...*/
	for(i=0;i<mixmod->n;i++){
		order[i] = i;
	}
	
	/*use gsl to shuffle*/
	gsl_ran_shuffle(r,order,mixmod->n,sizeof(int));
	
	for(i=0;i<mixmod->n_gibbs;i++){
	
		ind = order[i];
	
		/*current group*/
		g = mixmod->z[ind];
		
		/*point to the entry*/
		x = mixmod->Yobs[ind];
		
		/*cycle through remaining groups*/
		for(k=0;k<G;k++){
			
			if(!(k==g)){
			
				/*get the log probability ratio for this */
				probs[k] = get_log_relative_probability_for_gibbs(x,mixmod->components[mixmod->whereis[k]],mixmod->components[mixmod->whereis[g]],mixmod);
				
			//	printf("\nprobs[%d] = %.10f",k,probs[k]);
			
			}else{
			
				/*if k==g this is easy*/
			
				probs[k] = 0.0;
			
			}
		
		}
		
		max = get_max(probs,G);
		
		z = 0.;
		
		for(k=0;k<G;k++){
			probs[k] -= max;
			probs[k] = exp(probs[k]);
			z += probs[k];
		}
			
		for(k=0;k<G;k++){
			probs[k] /= z;
		}
		
		for(k=0;k<G;k++){
			if(isnan(probs[k]))
				printf("\nWARNING! WARNING! WARNING... NANS IN PROB VECTOR");
		}
						
		/*sample allocation from the vector of weights*/
		g_prime = sample_discrete(probs,G,r);
		
		//printf("\nNumber of groups = %d and g_prime = %d",G,g_prime);
		
		
		/*only need to execute this if the labelling is different*/
		if(!(g_prime == g)){
			
			ig = mixmod->whereis[g];
			ig_prime = mixmod->whereis[g_prime];
			
			//printf("\nNumber of groups = %d and ig = %d and ig_prime = %d",G,ig,ig_prime);
			/*need to recompute component[g_prime]->log_prob and component[g]->log_prob and 
				update the relevant stored quantities*/
			
			mixmod->z[ind] = g_prime;
			
			/*udpate component g*/
			mixmod->components[ig]->n_g -= 1;
			mixmod->components[ig_prime]->n_g += 1;
			
			for(j=0;j<d;j++){
			
				/*update the component counts*/
				
				ii = mixmod->Y[j][ind];
					
				mixmod->components[ig]->N[j][ ii ] -= 1;
				mixmod->components[ig_prime]->N[j][ ii ] += 1;
				
			}
			
			/*recompute the marginal likelihood of both components*/
			
			recompute_marginal_likelihood_component(mixmod->components[ig],mixmod);
			recompute_marginal_likelihood_component(mixmod->components[ig_prime],mixmod);
				
		}
	
	}
	
	
	free(probs);
	free(order);

	//printf("\nleaving Gibbs...\n");
	
	return(TRUE);
}

double get_log_relative_probability_for_gibbs(int *x,struct component *component_k,struct component *component_g,struct mix_mod *mixmod)
/*compute log of the relative probability for assigning entry where x is a pointer to the datapoint*/
{
	int i,j;
	double t1,t2,t3,t4,ll,I;

	
	t1 = 0.;
	t2 = 0.;
	
	for(j=0;j<mixmod->d;j++){
	
		if(mixmod->varindicator[j]){
	
			t1 += lgamma(mixmod->ncat[j]*mixmod->beta) - mixmod->ncat[j]*lgamma(mixmod->beta) -lgamma(component_k->n_g + 1. + mixmod->ncat[j]*mixmod->beta);
			t2 += lgamma(mixmod->ncat[j]*mixmod->beta) - mixmod->ncat[j]*lgamma(mixmod->beta) -lgamma(component_g->n_g - 1. + mixmod->ncat[j]*mixmod->beta);
		
			for(i=0;i<mixmod->ncat[j];i++){
			
					I = (x[j] == i) ? 1 : 0 ;
				
					t1 += lgamma(component_k->N[j][i] + I + mixmod->beta);
					t2 += lgamma(component_g->N[j][i] - I + mixmod->beta);
			
			}
		
		}
		
	}
	
	/*add all up*/
	
	t3 = lgamma(component_k->n_g+1.+mixmod->alpha)+lgamma(component_g->n_g-1.+mixmod->alpha) 
		+ t1 + t2;
	
	ll = t3 - component_k->log_prob - component_g->log_prob;
	
	return(ll);

}

int update_allocations_with_metropolis_move_1(struct mix_mod *mixmod,gsl_rng *r,int *accepted,int *proposed)
	/*this performs the move M1 taken from Nobile and Fearnside (2007) Stats and Computing 17: p147-162*/
{

	//printf("\nwithin Move 1...\n");
	
	/*DO NOT PERFORM THIS MOVE UNLESS THERE ARE AT LEAST TWO COMPONENTS*/
	if(mixmod->G < 2){
		
		return(TRUE);
	
	}

	*proposed += 1;

	int i,ii,kk,j,k,g1,g2,ig1,ig2,ntot,*indexes,*proposed_alloc;
	double p,log_acceptance,ag1=1.,ag2=1.;
	struct component *component_g1,*component_g2;
	
	/*the integers g1 and g2 give the components, and ig1 and ig2 their whereis value*/
	/*the doubles ag1 and ag2 give the parameters to the Beta distribution for generating p_1
		take default uniform*/
	
	/*sample the two components*/
	g1 = gsl_rng_uniform_int(r,mixmod->G);
	g2 = g1;
	while(g2 == g1){
		g2 = gsl_rng_uniform_int(r,mixmod->G);
	}
	
	/*find where in mixmod->components g1 and g2 are*/
	ig1 = mixmod->whereis[g1];
	ig2 = mixmod->whereis[g2];
	
	ntot = mixmod->components[ig1]->n_g + mixmod->components[ig2]->n_g;
	
	/*DO NOT PERFORM THIS MOVE UNLESS ntot > 0*/
	if(ntot == 0){
	
		return(TRUE);
		
	}
	
	/*allocate space for proposal stuff...*/
	
	component_g1 =(struct component *)malloc(sizeof(struct component));
	component_g2 =(struct component *)malloc(sizeof(struct component));
	
	allocate_component(component_g1,mixmod);
	allocate_component(component_g2,mixmod);
	
	/*allocate a vector to keep track of indexes*/
	indexes = calloc(ntot,sizeof(int));
	proposed_alloc = calloc(ntot,sizeof(int));
	
	k=0;
	for(i=0;i<mixmod->n;i++){
		if(mixmod->z[i] == g1 || mixmod->z[i] == g2){
			indexes[k] = i;
			k+=1;
		}
	}
	
	/*check is ok*/
	if(!(k==ntot)){
		mixmod_warning(2);
		//printf("\nValue of k=%d and ntot = %d, g1 = %d, g2 = %d",k,ntot,g1,g2);
		//for(i=0;i<mixmod->n;i++) printf("%d,",mixmod->z[i]);
	}
	
	/*generate p and begin reallocation*/
	p = gsl_ran_beta(r,ag1,ag2);
	
	/*now propose reallocation*/
	
	component_g1->n_g = 0;
	component_g2->n_g = 0;
	
	for(i=0;i<ntot;i++){
	
		ii = indexes[i];
	
		if(gsl_rng_uniform(r) < p){
		
			/*reallocate to g1*/
			proposed_alloc[i] = g1;
			component_g1->n_g += 1;
			for(j=0;j<mixmod->d;j++){
				component_g1->N[j][ mixmod->Y[j][ii] ] += 1;
			}
			
		}else{
		
			/*reallocate to g2*/
			proposed_alloc[i] = g2;
			component_g2->n_g += 1;
			for(j=0;j<mixmod->d;j++){
				component_g2->N[j][ mixmod->Y[j][ii] ] += 1;
			}
		
		}		
		
	}
	
	/*evaluate log of acceptance probability*/
	
	recompute_marginal_likelihood_component(component_g1,mixmod);
	recompute_marginal_likelihood_component(component_g2,mixmod);
	
	log_acceptance = component_g1->log_prob + component_g2->log_prob - mixmod->components[ig1]->log_prob - mixmod->components[ig2]->log_prob
	+lgamma(mixmod->alpha + mixmod->components[ig1]->n_g) + lgamma(mixmod->alpha + mixmod->components[ig2]->n_g) 
			- lgamma(mixmod->alpha + component_g1->n_g) - lgamma(mixmod->alpha + component_g2->n_g);;
	
	//printf("\nThe value of log acceptance is %.10f,",log_acceptance);
	
	if(log(gsl_rng_uniform(r))<log_acceptance){
	
		/*do the swap!!!*/
		
		*accepted += 1;
		
		for(i=0;i<ntot;i++){
			mixmod->z[indexes[i]] = proposed_alloc[i];
		}
		
		/*copy over the accepted components*/
		
		copy_component(component_g1,mixmod->components[ig1],mixmod);
		copy_component(component_g2,mixmod->components[ig2],mixmod);
	
	}
	

	free_component(component_g1,mixmod);
	free_component(component_g2,mixmod);
	
	free(component_g1);
	free(component_g2);
	
	free(indexes);
	free(proposed_alloc);

	//printf("\nleaving Move 1...\n");
	
	return(TRUE);
}

int update_allocations_with_metropolis_move_2(struct mix_mod *mixmod,gsl_rng *r,int *accepted,int *proposed)
/*this performs the move M2 taken from Nobile and Fearnside (2007) Stats and Computing 17: p147-162*/
{

	/*DO NOT PERFORM THIS MOVE UNLESS THERE ARE AT LEAST TWO COMPONENTS*/
	if(mixmod->G < 2){
		
		return(TRUE);
	
	}

	int i,ii,j,k,g1,g2,ig1,ig2,curr_n_g1,curr_n_g2,m,ntot,c=0;
	int *indexes,*order;
	double log_acceptance;
	struct component *component_g1,*component_g2;
	
	/*sample the two components*/
	g1 = gsl_rng_uniform_int(r,mixmod->G);
	g2 = g1;
	while(g2 == g1){
		g2 = gsl_rng_uniform_int(r,mixmod->G);
	}	

	/*find where in mixmod->components g1 and g2 are*/
	ig1 = mixmod->whereis[g1];
	ig2 = mixmod->whereis[g2];
	
	if(mixmod->components[ig1]->n_g == 0){
		/*cannot perform move in this case... return*/
		return(TRUE);
	}
	
	/*current component sizes*/
	curr_n_g1 = mixmod->components[ig1]->n_g;
	curr_n_g2 = mixmod->components[ig2]->n_g;
	
	/*allocate the candidate components*/
	
	component_g1 =(struct component *)malloc(sizeof(struct component));
	component_g2 =(struct component *)malloc(sizeof(struct component));
	
	allocate_component(component_g1,mixmod);
	allocate_component(component_g2,mixmod);
	
	
	*proposed += 1;
	
	order = calloc(curr_n_g1,sizeof(int));
	for(i=0;i<curr_n_g1;i++){
		order[i] = i;
	}
	
	/*shuffle the order*/
	gsl_ran_shuffle(r,order,curr_n_g1,sizeof(int));
	
	indexes = calloc(curr_n_g1,sizeof(int));
	for(i=0;i<mixmod->n;i++){
		if(mixmod->z[i] == g1){
			indexes[c] = i;
			c += 1;
		}
	}
	
	m = gsl_rng_uniform_int(r,curr_n_g1);
	
	/*try to reallocate the first i=1,...,m in indexes[order[i]]*/
	
	copy_component(mixmod->components[ig1],component_g1,mixmod);
	copy_component(mixmod->components[ig2],component_g2,mixmod);
	
	component_g1->n_g -= m;
	component_g2->n_g += m;
	
	for(i=0;i<m;i++){
	
		k = order[i];
		ii = indexes[k];
		
		for(j=0;j<mixmod->d;j++){
		
			component_g1->N[j][ mixmod->Yobs[ii][j] ] -= 1;		
			component_g2->N[j][ mixmod->Yobs[ii][j] ] += 1;	
			
		}
		
	}
	
	/*compute the log acceptance probability*/
	
	recompute_marginal_likelihood_component(component_g1,mixmod);
	recompute_marginal_likelihood_component(component_g2,mixmod);
	
	log_acceptance = component_g1->log_prob + component_g2->log_prob - mixmod->components[ig1]->log_prob - mixmod->components[ig2]->log_prob
							+ log(component_g1->n_g + m) - log(component_g2->n_g) + lgamma(component_g1->n_g+m+1.) + lgamma(component_g2->n_g-m+1.)
								-lgamma(component_g1->n_g + 1.) - lgamma(component_g2->n_g+1.);
	
	if(log(gsl_rng_uniform(r))<log_acceptance){
		
		/*do the swap*/
		
		*accepted += 1;
		
		for(i=0;i<m;i++){
			k = order[i];
			ii = indexes[k];
			mixmod->z[ii] = g2;		
		}
		
		/*copy over the accepted components*/
		copy_component(component_g1,mixmod->components[ig1],mixmod);
		copy_component(component_g2,mixmod->components[ig2],mixmod);
	
	}
	

	free_component(component_g1,mixmod);
	free_component(component_g2,mixmod);
	
	free(component_g1);
	free(component_g2);

	free(order);
	free(indexes);
	
	return(TRUE);
}



int update_allocations_with_metropolis_move_3(struct mix_mod *mixmod,gsl_rng *r,int *accepted,int *proposed)
/*this performs the move M3 taken from Nobile and Fearnside (2007) Stats and Computing 17: p147-162*/
{

	/*DO NOT PERFORM THIS MOVE UNLESS THERE ARE AT LEAST TWO COMPONENTS*/
	if(mixmod->G < 2){
		
		return(TRUE);
	
	}

	int i,ii,j,k,g1,g2,ig1,ig2,curr_n_g1,curr_n_g2,m,ntot,c=0,d = mixmod->d,identify_g1,identify_g2,id;
	int *indexes,*order,*proposed_allocation;
	double w,log_acceptance,log_transition_z_to_zprime=0.,log_transition_zprime_to_z=0.,l1,l2,p1,p2,max;
	struct component *component_g1,*component_g2,*component_backward_g1,*component_backward_g2;
	
	*proposed += 1;
	
	/*sample the two components*/
	g1 = gsl_rng_uniform_int(r,mixmod->G);
	g2 = g1;
	while(g2 == g1){
		g2 = gsl_rng_uniform_int(r,mixmod->G);
	}	

	/*find where in mixmod->components g1 and g2 are*/
	ig1 = mixmod->whereis[g1];
	ig2 = mixmod->whereis[g2];
	
	ntot = mixmod->components[ig1]->n_g + mixmod->components[ig2]->n_g;
	
	if(ntot == 0){
		/*cannot perform if both components empty*/
		return(TRUE);
	}
	
	indexes = calloc(ntot,sizeof(int));
	order = calloc(ntot,sizeof(int));
	proposed_allocation = calloc(ntot,sizeof(int));
	
	/*this move can still be done if either component empty*/
	
	for(i=0;i<mixmod->n;i++){	
		if(mixmod->z[i] == g1 || mixmod->z[i] == g2){
			indexes[c] = i;
			c += 1;
		}
	}
	
	for(i=0;i<ntot;i++){
		order[i] = i;
	}
	
	/*shuffle the order*/
	gsl_ran_shuffle(r,order,ntot,sizeof(int));
	
	/*allocate the candidate components*/
	
	component_g1 =(struct component *)malloc(sizeof(struct component));
	component_g2 =(struct component *)malloc(sizeof(struct component));
	
	allocate_component(component_g1,mixmod);
	allocate_component(component_g2,mixmod);
	
	component_g1->n_g = 0;
	component_g2->n_g = 0;

	
	/*randomizing this part should give a 50% acceptance*/

	k = order[0];
	ii = indexes[k];
	
	if(/*gsl_rng_uniform(r) < 0.5*/mixmod->z[ii] == g1){
	
		/*put it into component_g1*/
		
		component_g1->n_g += 1;
		
		for(j=0;j<d;j++){
			component_g1->N[j][ mixmod->Y[j][ii] ] += 1;
		}
		
		//identify_g1 = mixmod->z[ii];
	
		proposed_allocation[0] = g1;
		
		log_transition_z_to_zprime = log(0.5) - log(1.);
	
	}else{
	
		/*put it into component_g2*/
		
		component_g2->n_g += 1;
		
		for(j=0;j<d;j++){
			component_g2->N[j][ mixmod->Y[j][ii] ] += 1;
		}
	
		proposed_allocation[0] = g2;

		log_transition_z_to_zprime = log(0.5) - log(1.);

	}
	
	/*identify this as being in the same component as original
		...this allows the computing of the backwards probability*/
	
	log_transition_zprime_to_z += log(0.5) - log(1.);
		
	
	for(i=1;i<ntot;i++){
	
		k = order[i];
		ii = indexes[k];
		
		/*do the proposed component values, then sample and make changes*/
		
		/*compute probability generated from g1*/
		
		l1 = compute_log_data_probability_with_inclusion_in_component(mixmod->Yobs[ii],component_g1,mixmod)
				+ compute_log_data_probability_component(component_g2,mixmod);
		
		l2 = compute_log_data_probability_component(component_g1,mixmod)
				+ compute_log_data_probability_with_inclusion_in_component(mixmod->Yobs[ii],component_g2,mixmod);
		
		w = ((mixmod->alpha + component_g1->n_g)/(mixmod->alpha + component_g2->n_g))*exp(l1-l2);
		
		p1 = w/(1.+w);
		
		/*make a draw*/
		
		if(gsl_rng_uniform(r) < p1){
		
			/*put it in g1*/
			
			component_g1->n_g += 1;
			
			for(j=0;j<d;j++){
				component_g1->N[j][ mixmod->Y[j][ii] ] += 1;
			}
			
			if(!(mixmod->z[ii] == g1)){
				log_transition_z_to_zprime += log(p1);
				log_transition_zprime_to_z += log(1.-p1);
			}
			
			proposed_allocation[i] = g1;
			
		}else{
		
		
			/*put it in g2*/
			
			component_g2->n_g += 1;
			
			for(j=0;j<d;j++){
				component_g2->N[j][ mixmod->Y[j][ii] ] += 1;
			}
			
			if(!(mixmod->z[ii] == g2)){
				log_transition_z_to_zprime += log(1.-p1);
				log_transition_zprime_to_z += log(p1);
			}
		
			proposed_allocation[i] = g2;
		}
		
	}
	

	/*compute the acceptance probability*/
	
	recompute_marginal_likelihood_component(component_g1,mixmod);
	recompute_marginal_likelihood_component(component_g2,mixmod);
	
	log_acceptance = component_g1->log_prob + component_g2->log_prob 
						- mixmod->components[ig1]->log_prob - mixmod->components[ig2]->log_prob
						+ log_transition_zprime_to_z - log_transition_z_to_zprime;
	
	//printf("\n%.4f \t %.4f \t %.4f ",log_acceptance,log_transition_zprime_to_z,log_transition_z_to_zprime );
						
	if(log(gsl_rng_uniform(r))<log_acceptance){
	
		*accepted += 1;
	
		/*accept the move and update all quantities*/
		
		/*allocations first*/
	
		copy_component(component_g1,mixmod->components[ig1],mixmod);
		copy_component(component_g2,mixmod->components[ig2],mixmod);
		
		
		for(i=0;i<ntot;i++){
				
			k = order[i];
			ii = indexes[k];
			mixmod->z[ii] = proposed_allocation[i];
			
		}
	
	}
	
	/*free up all memory*/
	
	free_component(component_g1,mixmod);
	free_component(component_g2,mixmod);
	
	free(component_g1);
	free(component_g2);

	free(indexes);
	free(order);
	free(proposed_allocation);
	
	return(TRUE);

}


/*eject and absorb moves*/

int update_allocations_with_ejection_move(struct mix_mod *mixmod,gsl_rng *r,int *accepted,int *proposed,double pr_ej_G,double pr_ej_Gp1)
/*this is the ejection move for one comonent ejecting another*/
{

	int i,ii,j,k,g1,g2,ig1,ig2,curr_n_g1,curr_n_g2,m,ntot,c=0,d = mixmod->d,identify_g1,identify_g2,id;
	int *indexes,*order,*proposed_allocation,G = mixmod->G;
	double w,a,prob_put_in_g2,log_acceptance,log_transition_z_to_zprime=0.,log_transition_zprime_to_z=0.;
	struct component *component_g1,*component_g2;

	/*do a check for the constraint*/
	
	int S=0,D=0;
	double logP=0.,cstr;
	
	for(j=0;j<mixmod->d;j++){
	  if(mixmod->varindicator[j]){
	    S += mixmod->ncat[j];
	    logP += log(mixmod->ncat[j]);
	    D += 1;
	  }
	}
	
	/*check constraint*/
	cstr = logP - log((S - D + 1)*(mixmod->G+1));
	if(!(cstr>0.)){
	  /*model will not be identifiable*/
	 // Rprintf("\nConstraint not satisfied");
	  return -1;
	}
	
	
	*proposed += 1;
	
	/*sample the ejecting component*/
	g1 = gsl_rng_uniform_int(r,G);
	g2 = G;

	/*find where in mixmod->components g1 is*/
	ig1 = mixmod->whereis[g1];
	
	/*if this component is empty we need a special case*/
	
	component_g1 =(struct component *)malloc(sizeof(struct component));
	component_g2 =(struct component *)malloc(sizeof(struct component));
	
	allocate_component(component_g1,mixmod);
	allocate_component(component_g2,mixmod);

	component_g1->n_g = 0;
	component_g2->n_g = 0;
	
	ntot = mixmod->components[ig1]->n_g;	
	
	if(ntot > 0){
		//printf("\nin there 1");
	
		/*this is the case for ejecting from a non-empty component*/
		
		
		indexes = calloc(ntot,sizeof(int));
		proposed_allocation = calloc(ntot,sizeof(int));
		
		c = 0;
		
		for(i=0;i<mixmod->n;i++){
			if(mixmod->z[i] == g1){
				indexes[c] = i;
				c += 1;
			}
		}	
		
				//printf("\nin there 2");
		/*copy the contents of mixmod->components[ig1] into*/
		copy_component(mixmod->components[ig1],component_g1,mixmod);	
		
				//printf("\nin there 3");
		
		/*generate the probability of assignment to the new component*/
		
		if(ntot < 4){
			/*just set a = 100*/
			a = 100.;
			prob_put_in_g2 = gsl_ran_beta(r,a,a);
		}else{
			a = mixmod->table_a[ntot-1];
			prob_put_in_g2 = gsl_ran_beta(r,a,a);
		}
	
		/*now reassign or not*/
		
		for(i=0;i<ntot;i++){
		
			ii = indexes[i];
			
			if(gsl_rng_uniform(r)<prob_put_in_g2){
			
				/*then move this point to g2*/
				
				/*first take out of component_g1*/
				
				component_g1->n_g -= 1;
				
				for(j=0;j<d;j++){
					component_g1->N[j][ mixmod->Y[j][ii] ] -= 1;
				}
				
				/*and put in the new component*/
				
				component_g2->n_g += 1;
				
				for(j=0;j<d;j++){
					component_g2->N[j][ mixmod->Y[j][ii] ] += 1;
				}	
				
				proposed_allocation[i] = g2;
			
			}else{
			
				proposed_allocation[i] = g1;
				
			}
		
		
		}
	
	}
	
	recompute_marginal_likelihood_component(component_g1,mixmod);
	recompute_marginal_likelihood_component(component_g2,mixmod);	
	
	/*compute the acceptance probability, remembering to add all necessary normalizing constants*/
	
	w = log_normalizing_constant_model(G+1,mixmod) - log_normalizing_constant_model(G,mixmod);
	
	//printf("\nBirth: w = %.10f ",w);

	log_transition_z_to_zprime = log(pr_ej_G);
		
	if(ntot > 0){
		log_transition_z_to_zprime +=  lgamma(2.*a) - 2.*lgamma(a) + lgamma(a + component_g1->n_g) 
									+ lgamma(a + component_g2->n_g) - lgamma(2.*a + ntot);
	}
	
	log_transition_zprime_to_z = log(1.-pr_ej_Gp1);
	
	log_acceptance = w + component_g1->log_prob + component_g2->log_prob - mixmod->components[ig1]->log_prob 
							- log_transition_z_to_zprime + log_transition_zprime_to_z + mixmod->log_prior_G[G+1] - mixmod->log_prior_G[G];
							
	
	//printf("\nlog_acceptance = %.10f",log_acceptance);
	
	if(log(gsl_rng_uniform(r)) < log_acceptance){
	
		*accepted += 1;
	
		/*update the model structure*/
		
		mixmod->G += 1;
		
		/*relabel the appropriate indexes*/
		if(ntot>0){
			for(i=0;i<ntot;i++){
				ii = indexes[i];
				mixmod->z[ii] = proposed_allocation[i];
			}
		}
		
		int new_whereis=0;
		
		/*begin to encode an unused component by -1 in mixmod->whereis*/
		while(mixmod->components[new_whereis]->in_use == TRUE){
			new_whereis += 1;
		}
		
		
		/*put new componenet G in new_whereis*/
		/*this will now be indexed as component G*/
		
		mixmod->whereis[G] = new_whereis;
		mixmod->components[new_whereis]->in_use = TRUE;
		
		copy_component(component_g1,mixmod->components[ig1],mixmod);
		copy_component(component_g2,mixmod->components[new_whereis],mixmod);
		
		/*now do a swap between component G and one of the others...*/
		
		/*generate component randomly*/
		
		g1 = gsl_rng_uniform_int(r,G+1);
		
		if( g1 != G ){
		
			/*do a swap!*/
			
			ig1 = mixmod->whereis[g1];
			ig2 = mixmod->whereis[G];
			
			mixmod->whereis[g1] = ig2;
			mixmod->whereis[G] = ig1;
			
			
			/*copy_component(mixmod->components[ig1],component_g1,d);
			copy_component(mixmod->components[ig2],mixmod->components[ig1],d);
			copy_component(component_g1,mixmod->components[ig2],d);*/

			/*relabel the appropriate indexes*/
			for(i=0;i<mixmod->n;i++){
				//ii = indexes[i];
				if(mixmod->z[i] == g1){
					mixmod->z[i] = G;
				}else if(mixmod->z[i] == G){
					mixmod->z[i] = g1;
				}
			}
			
		}
		
		/*for(i=0;i<mixmod->G;i++){
			print_component(i,mixmod);
		}*/
	
	}
	
	
	/*for(k=0;k<mixmod->maxgroups;k++)
		printf("\nComponent %d is in %d",k,mixmod->whereis[k]);*/
	
	free_component(component_g1,mixmod);
	free_component(component_g2,mixmod);
	
	free(component_g1);
	free(component_g2);

	if(ntot>0){
		free(indexes);
		free(proposed_allocation);
	}
	
	
}

void print_component(int i,struct mix_mod *mixmod,FILE *fp)
{

	int k,j,ii;
	
	k = mixmod->whereis[i];
	
	fprintf(fp,"\nPrintout of component %d. Position in whereis = %d \n \t in use? = %d \n \t n_g = %d \n \t sum =",i,k,mixmod->components[k]->in_use,mixmod->components[k]->n_g);
	
	fprintf(fp,"\n");
	
	for(j=0;j<mixmod->d;j++){
		fprintf(fp,"\n \t Variable %d: ",j);
		for(ii=0;ii<mixmod->ncat[j];ii++){
		
			fprintf(fp,"  %d  ",mixmod->components[k]->N[j][ii]);
			
		}
	
	}
		
	fprintf(fp,"\n \t Log prob = %.10f",mixmod->components[k]->log_prob);
	fprintf(fp,"\n\n");


}



int update_allocations_with_absorb_move(struct mix_mod *mixmod,gsl_rng *r,int *accepted,int *proposed,double pr_ej_G,double pr_ej_Gm1)
{
	int i,ii,j,k,g1,g2,ig1,ig2,curr_n_g1,curr_n_g2,m,ntot,c=0,d = mixmod->d,identify_g1,identify_g2,id;
	int *indexes,*order,*proposed_allocation,G = mixmod->G,n_g2;
	double w,a,prob_put_in_g2,log_acceptance,log_transition_z_to_zprime=0.,log_transition_zprime_to_z=0.;
	struct component *component_g1,*component_g2;
	
	/*do a check for the constraint*/
	
	int S=0,D=0;
	double logP=0.,cstr;
	
	for(j=0;j<mixmod->d;j++){
	  if(mixmod->varindicator[j]){
	    S += mixmod->ncat[j];
	    logP += log(mixmod->ncat[j]);
	    D += 1;
	  }
	}
	
	/*check constraint*/
	cstr = logP - log((S - D + 1)*(mixmod->G-1));
	if(!(cstr>0)){
	  /*model will not be identifiable*/
	 // Rprintf("\nConstraint not satisfied");
	  return -1;
	}

	
	*proposed += 1;
	
	/*choose component to absorb into and to absorb*/
	g1 = gsl_rng_uniform_int(r,G);
	g2 = g1;
	while(g2 == g1){
		g2 = gsl_rng_uniform_int(r,G);
	}
	
	/*find where in mixmod->components g1 and g2 are*/
	ig1 = mixmod->whereis[g1];
	ig2 = mixmod->whereis[g2];
	
	/*use a component to store the proposed*/
	
	component_g1 =(struct component *)malloc(sizeof(struct component));
	
	allocate_component(component_g1,mixmod);
	
	component_g1->n_g = 0;
	
	/*form the proposed component by combining the two other components...*/
	
	ntot = mixmod->components[ig1]->n_g + mixmod->components[ig2]->n_g;

	n_g2 = mixmod->components[ig2]->n_g;

	copy_component(mixmod->components[ig1],component_g1,mixmod);
	
	if(n_g2 > 0){
	
		/*this is the case for non-empty components*/
		indexes = calloc(n_g2,sizeof(int));
		proposed_allocation = calloc(n_g2,sizeof(int));
		
		c = 0;
		
		for(i=0;i<mixmod->n;i++){
			if(mixmod->z[i] == g2){
				indexes[c] = i;
				c += 1;
			}
		}
		
		/*now just place everything in component_g1*/
		
		for(i=0;i<n_g2;i++){
		
			ii = indexes[i];
			
			component_g1->n_g += 1;
			
			for(j=0;j<d;j++){
				component_g1->N[j][ mixmod->Y[j][ii] ] += 1;
			}	
			
		}	
	
	}
	
	recompute_marginal_likelihood_component(component_g1,mixmod);	
	
	/*compute the acceptance probability, remembering to add all necessary normalizing constants*/
	
	/* w = log of difference in normalizing constants*/
	
	w = log_normalizing_constant_model(G-1,mixmod) - log_normalizing_constant_model(G,mixmod);
	
	//printf("\nDeath: w = %.10f ",w);
	
	log_transition_zprime_to_z = log(pr_ej_Gm1);
		
	if(ntot > 0){
	
		if(ntot < 4){
			a = 100.;
		}else{
			a = mixmod->table_a[ntot-1];
		}
	
		log_transition_zprime_to_z +=  lgamma(2.*a) - 2.*lgamma(a) + lgamma(a + mixmod->components[ig1]->n_g) + lgamma(a + mixmod->components[ig2]->n_g) - lgamma(2.*a + ntot);
		
	}
	
	log_transition_z_to_zprime = log(1.-pr_ej_G);	
	
	log_acceptance = w + component_g1->log_prob - mixmod->components[ig1]->log_prob - mixmod->components[ig2]->log_prob
							- log_transition_z_to_zprime + log_transition_zprime_to_z + mixmod->log_prior_G[G-1] - mixmod->log_prior_G[G];	
	

	//printf("\nlog_acceptance absorb move is %.10f\n",log_acceptance);

	if(log(gsl_rng_uniform(r)) < log_acceptance){
	
		//printf("\nlog_acceptance absorb move is %.10f\n",log_acceptance);
	
		*accepted += 1;
	
		/*update the model structure*/
		
		mixmod->G -= 1;
		
		/*relabel the appropriate indexes*/
		if(n_g2 > 0){
			for(i=0;i< n_g2;i++){
				ii = indexes[i];
				mixmod->z[ii] = g1;
			}
		}
		
		copy_component(component_g1,mixmod->components[ig1],mixmod);
		
		mixmod->components[ig2]->in_use = FALSE;
		//mixmod->whereis[g2] = -1;
		
		/*should relabel everything from component g2 upwards*/
		
		for(k=g2+1;k<G;k++){
		
			for(i=0;i<mixmod->n;i++){
				if(mixmod->z[i] == k){
					mixmod->z[i] = k-1;
				}
			}
			
			j = mixmod->whereis[k];
			//printf("\nvalue of j = %d",j);
			mixmod->whereis[k-1] = j;
			//mixmod->whereis[k] = -1;
		
		}
		
		mixmod->whereis[G-1] = -1;
		
		/*for(k=0;k<mixmod->maxgroups;k++)
			printf("\nComponent %d is in %d",k,mixmod->whereis[k]);*/

		
	}
	
	free_component(component_g1,mixmod);
	free(component_g1);
	
		
	if(n_g2 > 0){
		free(indexes);
		free(proposed_allocation);
	}	

}

/*----------------------------------- add/remove variables-------------------------------------------*/


void update_model_by_removing_variable(struct mix_mod *mixmod,gsl_rng *r,int *accepted,int *proposed,int d_in)
/*not used anymore...*/
{

	*proposed += 1;

	int i,j,k,vr,*in;
	double *logprobs,lf_prob,lr_prob,lp_current,lp_proposed,lpr=0.;
	
	in = calloc(d_in,sizeof(int));
	logprobs = calloc(mixmod->G,sizeof(double));
	
	k = 0;
	for(i=0;i<mixmod->d;i++){
		if(mixmod->varindicator[i]){
			in[k] = i;
			k++;
		}
	}
	
	if(d_in == mixmod->d){
	  lpr = log(0.5);
	}
	
	lf_prob = -log(d_in);
	lr_prob = -log(mixmod->d - d_in + 1.);
	
	/*draw one of the variables to remove*/
	k = gsl_rng_uniform_int(r,d_in);
	
	/*remove the variable vr*/
	vr = in[k];
	
	/*temporarily set mixmod->varindicator[vr] =0*/
	mixmod->varindicator[vr] = 0;
	
	/*temporary storage of the current log-probs*/
	lp_current = 0.;
	lp_proposed = 0.;
	for(i=0;i<mixmod->G;i++){
		logprobs[i] = mixmod->components[ mixmod->whereis[i] ]->log_prob;
		lp_current += logprobs[i];
		recompute_marginal_likelihood_component(mixmod->components[ mixmod->whereis[i] ],mixmod);
		lp_proposed += mixmod->components[ mixmod->whereis[i] ]->log_prob;
	}
	
	double logratio = lp_proposed - lp_current - lf_prob + lr_prob + lpr;
	
	//Rprintf("\nlog accept for remove var = %.10f",logratio);
	
	if(log(gsl_rng_uniform(r)) < logratio){
		
		*accepted += 1;
	
		/*accept*/
	
	}else{
	
		mixmod->varindicator[vr] = 1;
		for(i=0;i<mixmod->G;i++){
			mixmod->components[ mixmod->whereis[i] ]->log_prob = logprobs[i];
		}

	}
	
	free(in);
	free(logprobs);
	
	return;

}


void update_model_by_adding_variable(struct mix_mod *mixmod,gsl_rng *r,int *accepted,int *proposed,int d_in)
/*not used anymore...*/
{

	*proposed += 1;

	int i,j,k,va,*out;
	double *logprobs,lf_prob,lr_prob,lp_current,lp_proposed,lpr=0.;
	
	out = calloc(mixmod->d-d_in,sizeof(int));
	logprobs = calloc(mixmod->G,sizeof(double));
	
	k = 0;
	for(i=0;i<mixmod->d;i++){
		if(!mixmod->varindicator[i]){
			out[k] = i;
			k++;
		}
	}
	
	if(d_in == 1){
	  
	  lpr = log(.5);
	  
	}
	
	lf_prob = -log(mixmod->d - d_in);
	lr_prob = -log(d_in + 1.);
	
	/*draw one of the variables to remove*/
	k = gsl_rng_uniform_int(r,mixmod->d - d_in);
	
	/*remove the variable vr*/
	va = out[k];
	
	/*temporarily set mixmod->varindicator[vr] =0*/
	mixmod->varindicator[va] = 1;
	
	/*temporary storage of the current log-probs*/
	lp_current = 0.;
	lp_proposed = 0.;
	for(i=0;i<mixmod->G;i++){
		logprobs[i] = mixmod->components[ mixmod->whereis[i] ]->log_prob;
		lp_current += logprobs[i];
		recompute_marginal_likelihood_component(mixmod->components[ mixmod->whereis[i] ],mixmod);
		lp_proposed += mixmod->components[ mixmod->whereis[i] ]->log_prob;
	}
	
	double logratio = lp_proposed - lp_current - lf_prob + lr_prob + lpr;
	
	if(log(gsl_rng_uniform(r)) < logratio){
		
		*accepted += 1;
	
		/*accept*/
	
	}else{
	
		mixmod->varindicator[va] = 0;
		for(i=0;i<mixmod->G;i++){
			mixmod->components[ mixmod->whereis[i] ]->log_prob = logprobs[i];
		}

	}
	
	free(out);
	free(logprobs);
	
	return;

}

void update_model_by_variable_include_exclude(struct mix_mod *mixmod,gsl_rng *r,int *accepted,int *proposed,int var)
{
  
	int i,j,S=0,D=0,Sn,Dn;
	double logP=0.,logPn,cstr;
	double *logprobs,logprob_undiscriminating,logratio,lp_current,lp_proposed,l_ratio_prior_variable_inclusion;
	
	for(j=0;j<mixmod->d;j++){
	  if(mixmod->varindicator[j]){
	    S += mixmod->ncat[j];
	    logP += log(mixmod->ncat[j]);
	    D += 1;
	  }
	}
	
	
	if(mixmod->varindicator[var]){
	  
	  /*this is the removal case-- check constraint and return if not possible*/
	  Sn = S - mixmod->ncat[var];
	  logPn = logP - log(mixmod->ncat[var]);
	  Dn = D -1;
	  
	  cstr = logPn - log(( Sn - Dn + 1 )*mixmod->G);
	  
	 // Rprintf("\nIn the removal case the cstr was %d",cstr);
	  
	  if(!(cstr>0)){
	    return;
	  }
	  
	  mixmod->varindicator[var] = 0;
	  
	  l_ratio_prior_variable_inclusion = l_prior_variable_include(D,mixmod) - l_prior_variable_include(D+1,mixmod);
	  
	}else{
	  
	  /*the is the inclusion case-- check constraint and return if not possible*/
	  Sn = S + mixmod->ncat[var];
	  logPn = logP + log(mixmod->ncat[var]);
	  Dn = D + 1;
	  
	  cstr = logPn - log(( Sn - Dn + 1 )*mixmod->G);
	  
	 // Rprintf("\nIn the add case the cstr was %d",cstr);
	  
	  if(!(cstr > 0)){
	    return;
	  }
	  
	  mixmod->varindicator[var] = 1;
	  
	  l_ratio_prior_variable_inclusion = l_prior_variable_include(D,mixmod) - l_prior_variable_include(D-1,mixmod);
	  
	}
	
	*proposed += 1;
  
	logprobs = calloc(mixmod->G,sizeof(double));
	
	/*temporary storage of the current log-probs*/
	lp_current = 0.;
	lp_proposed = 0.;
	for(i=0;i<mixmod->G;i++){
		logprobs[i] = mixmod->components[ mixmod->whereis[i] ]->log_prob;
		lp_current += logprobs[i];
		recompute_marginal_likelihood_component(mixmod->components[ mixmod->whereis[i] ],mixmod);
		lp_proposed += mixmod->components[ mixmod->whereis[i] ]->log_prob;
	}	
	
	logprob_undiscriminating = mixmod->undiscriminating->log_prob;
	
	recompute_marginal_likelihood_undiscriminating_variables(mixmod->undiscriminating,mixmod);
	
	logratio = lp_proposed - lp_current + mixmod->undiscriminating->log_prob - logprob_undiscriminating + l_ratio_prior_variable_inclusion;
	
	/*Rprintf("\nThe log ratio is %.10f",logratio);
	Rprintf("\n\t proposed = %.10f",lp_proposed+mixmod->undiscriminating->log_prob);
	Rprintf("\n\t discriminating = %.10f",lp_proposed);
	Rprintf("\n\t undiscriminating = %.10f",mixmod->undiscriminating->log_prob);
	Rprintf("\n\t current = %.10f ",lp_current + logprob_undiscriminating);
	Rprintf("\n\t discriminating = %.10f ",lp_current );
	Rprintf("\n\t undiscriminating = %.10f",logprob_undiscriminating);
	Rprintf("\n\t prior ratio = %.10f ",l_ratio_prior_variable_inclusion);*/
	
	if(log(gsl_rng_uniform(r))<logratio){
	  
	  *accepted += 1;
	  
	}else{
	  
	  if(mixmod->varindicator[var]){
	    mixmod->varindicator[var] = 0;
	  }else{
	    mixmod->varindicator[var]=1;
	  }
	  
	  for(i=0;i<mixmod->G;i++){
	    mixmod->components[ mixmod->whereis[i] ]->log_prob = logprobs[i];
	  }
	  
	  mixmod->undiscriminating->log_prob = logprob_undiscriminating;
	  
	}
	
	free(logprobs);
  
  
	return;
  
}



/*-----------------------------------------------------------------------------------------------------*/



double compute_log_data_probability_with_inclusion_in_component(int *x,struct component *component,struct mix_mod *mixmod)
{

	int i,j,I;
	double log_prob = 0.;
	
	for(j=0;j<mixmod->d;j++){
	
		if(mixmod->varindicator[j]){
	
			log_prob += lgamma(mixmod->ncat[j] * mixmod->beta) - mixmod->ncat[j]*lgamma(mixmod->beta) - lgamma( component->n_g+1. + mixmod->ncat[j]*mixmod->beta );
		
			for(i=0;i<mixmod->ncat[j];i++){
		
				I = (x[j] == i) ?  1 : 0 ;
		
				log_prob += lgamma(component->N[j][i] + I + mixmod->beta);
		
			}
		
		}
		
	}

	/*if(isnan(log_prob)){
		mixmod_warning(1);
		printf("\nFrom compute_log_data_probability_with_inclusion_in_component. Result = %.10f,n_g = %d\n,sum_sq_norm = %.10f,sq_norm = %.10f",sum_sq_norm - sq_norm/(component->n_g+kappa) + kappa*xi2 + gamma,component->n_g,sum_sq_norm,sq_norm);
	}*/

	return(log_prob);
}

double compute_log_marginal_likelihood_with_inclusion_in_component(int *x,struct component *component,struct mix_mod *mixmod)
{
	/*function used for class prediction*/

	int i,j,I;
	double log_prob = 0.;
	
	log_prob = lgamma(component->n_g+1.+mixmod->alpha);
	
	for(j=0;j<mixmod->d;j++){
	
		if(mixmod->varindicator[j]){
	
			log_prob += lgamma(mixmod->ncat[j] * mixmod->beta) - mixmod->ncat[j]*lgamma(mixmod->beta) - lgamma( component->n_g + 1. + mixmod->ncat[j]*mixmod->beta );
		
			for(i=0;i<mixmod->ncat[j];i++){
		
				I = (x[j] == i) ?  1 : 0 ;
		
				log_prob += lgamma(component->N[j][i] + I + mixmod->beta);
		
			}
		
		}
		
	}

	return(log_prob);
}





double compute_log_data_probability_component(struct component *component,struct mix_mod *mixmod)
{

	int i,j;
	double log_prob = 0.;

	for(j=0;j<mixmod->d;j++){
	
		if(mixmod->varindicator[j]){
		
			log_prob += lgamma(mixmod->ncat[j] * mixmod->beta) - mixmod->ncat[j]*lgamma(mixmod->beta) - lgamma(component->n_g + mixmod->ncat[j]*mixmod->beta );
		
			for(i=0;i<mixmod->ncat[j];i++){
		
				log_prob += lgamma(component->N[j][i] + mixmod->beta);
		
			}
		
		}
		
	}
	
	/*if(isnan(log_prob)){
		mixmod_warning(1);
		printf("\nFrom compute_log_data_probability_component\n");
	}*/

	return(log_prob);	


}


void recompute_marginal_likelihood_component(struct component *component,struct mix_mod *mixmod)
{
	/*computing these quantities will save some time for the Gibbs update of the labels*/
	int i,j;
	double log_prob;
	
	log_prob = lgamma(component->n_g+mixmod->alpha);
	
	if(component->n_g > 0){
	
		for(j=0;j<mixmod->d;j++){
		
			if(mixmod->varindicator[j]){
			
				log_prob += lgamma(mixmod->ncat[j] *mixmod->beta) - mixmod->ncat[j]*lgamma(mixmod->beta) - lgamma(component->n_g + mixmod->ncat[j]*mixmod->beta);
			
				for(i=0;i<mixmod->ncat[j];i++){
			
					log_prob += lgamma(component->N[j][i] + mixmod->beta);
			
				}
			
			}
			
		}
		
	}
	
	/*if(isnan(log_prob)){
		mixmod_warning(1);
		printf("\nFrom recompute_marginal_likelihood_component\n");
	}*/
	
	component->log_prob = log_prob;

	return;
}


void recompute_marginal_likelihood_undiscriminating_variables(struct component *undiscriminating,struct mix_mod *mixmod)
{

	int i,j;
	double log_prob;
	
	log_prob = 0.;
	
	for(j=0;j<mixmod->d;j++){
	
		if(!mixmod->varindicator[j]){ /*variables not in mixture model*/
		
			log_prob += lgamma(mixmod->ncat[j]*mixmod->beta) - mixmod->ncat[j]*lgamma(mixmod->beta) - lgamma(undiscriminating->n_g + mixmod->ncat[j]*mixmod->beta);
			
			for(i=0;i<mixmod->ncat[j];i++){
			
				log_prob += lgamma(undiscriminating->N[j][i] + mixmod->beta);
			
			}
		
		}
		
	}
	
	undiscriminating->log_prob = log_prob;
	
	return;
	
}


double log_normalizing_constant_model(int G,struct mix_mod *mixmod)
/*returns the log of the normalizing constant for a model with G components*/
{
	double z;
	
	z =  lgamma(G*mixmod->alpha) - G*lgamma(mixmod->alpha) - lgamma(mixmod->n+G*mixmod->alpha);
	
	return(z); 	
}

double l_prior_variable_include(int D,struct mix_mod *mixmod)
{
	
	double l;
	
	l = D*log(mixmod->prior_prob_variable_include) + (mixmod->d - D)*log(1.-mixmod->prior_prob_variable_include);
	
	return(l);

}

double get_full_log_posterior(struct mix_mod *mixmod)
{

	double log_full_posterior = 0.;
	int i,d;

	/*model normalizing constant*/
	
	log_full_posterior += log_normalizing_constant_model(mixmod->G,mixmod);
	
	/*components - discriminating*/
	
	for(i=0;i<mixmod->G;i++){
		log_full_posterior += mixmod->components[ mixmod->whereis[i] ]->log_prob;
	}
	
	/*undiscriminating*/
	
	log_full_posterior += mixmod->undiscriminating->log_prob;
	
	/*prior on variable inclusion*/
	d = 0;
	for(i=0;i<mixmod->d;i++) d += mixmod->varindicator[i];
	
	log_full_posterior += l_prior_variable_include(d,mixmod);
	
	log_full_posterior += mixmod->log_prior_G[mixmod->G];
	
	return(log_full_posterior);
	
	
}

double get_full_log_posterior_x2(struct mix_mod *mixmod)
{

	double log_full_posterior;
	int j,i,c;

	/*model normalizing constant*/
	
	log_full_posterior = lgamma(mixmod->G*mixmod->alpha) - mixmod->G*lgamma(mixmod->alpha);
	
	for(i=0;i<mixmod->G;i++){
		log_full_posterior += (mixmod->components[i]->n_g + mixmod->alpha -1.)*log(mixmod->weights[i]);
		for(j=0;j<mixmod->d;j++){
			for(c=0;c<mixmod->ncat[j];c++){
				log_full_posterior += (mixmod->components[i]->N[j][c] + mixmod->beta - 1.)*log(mixmod->components[i]->prob_variables[j][c]);
			}
			log_full_posterior += lgamma(mixmod->ncat[j]*mixmod->beta) - mixmod->ncat[j]*lgamma(mixmod->beta);
		}
	}
	
	return(log_full_posterior);
}



struct results *do_mixmod_analysis(struct mix_mod *mixmod,int num_iteration,int num_burnin,int thin_by,int fixedG,int onlyGibbs,int selectVariables,int writeToFile,FILE *fp_memberships,FILE *fp_varindicator,FILE *fp_ngroups,FILE *fp_log_posterior,FILE *fp_pp_include,int *group_memberships, int *variable_inclusion_indicator, int *n_groups, double *log_joint_posterior,double *prior_include,int set_seed,int seed_value)
/*fixedG takes the value either TRUE or FALSE as defined in the macros*/
{

	int i,j,k,l,itmod,d_in,ej_case,vs_case,maxgroups = mixmod->maxgroups;
	
	int gap = (num_iteration - num_burnin)/(thin_by);
	
	//struct results res,*results;
	//results = &res;

	double pr_ej_G,pr_ej_Gm1,pr_ej_Gp1;
	
	const gsl_rng_type *T;
	gsl_rng *r;
	
	gsl_rng_env_setup();
 
  	T = gsl_rng_default;
  	r = gsl_rng_alloc(T);
  	
  	/*seed the random number generator from system time*/
  	if(!set_seed){
  		gsl_rng_set(r,(int)time(NULL));
  	}else{
  		gsl_rng_set(r,seed_value);
  	}
  	
	struct results *results = (struct results *)malloc(sizeof(struct results));
	allocate_results(results,num_iteration,num_burnin,thin_by,mixmod->n,mixmod->d,writeToFile);
	
	/*initialize with all variables in model*/
	for(j=0;j<mixmod->d;j++){
	   mixmod->varindicator[j] = TRUE;
	}
	
	for(l=0;l<num_iteration;l++){
	
		R_CheckUserInterrupt();
	
		/*for(i=0;i<mixmod->G;i++){
			print_component(i,mixmod,fpcheck);
		}*/
		
		/*check for violation of identifiability constraint*/
		int s = 0;
		double log_p = 0;
		int in = 0;
		
		if(l==0) Rprintf("\n");
		for(j=0;j<mixmod->d;j++){
		  
		  if(mixmod->varindicator[j]){
		    
		    s += mixmod->ncat[j];
		    log_p += log(mixmod->ncat[j]);
		    in += 1;
		    
		  }
		}
		
		if(!(log_p > log((s - in + 1)*mixmod->G)) && !(l>0)){
		  Rprintf("\n***Warning***: identifiability constraint not satisfied; log_p = %d, s=%d, in=%d, G=%d",log_p,s,in,mixmod->G);
		}
	
		update_allocations_with_gibbs(mixmod,r);
		
		if(!onlyGibbs){
			update_allocations_with_metropolis_move_1(mixmod,r,&(results->accepted_m1),&(results->proposed_m1));
			update_allocations_with_metropolis_move_2(mixmod,r,&(results->accepted_m2),&(results->proposed_m2));
			update_allocations_with_metropolis_move_3(mixmod,r,&(results->accepted_m3),&(results->proposed_m3));
		}
	
		if(!fixedG){

			if(mixmod->G == 1){
				ej_case = 0;
			}else if(mixmod->G == maxgroups){
				ej_case = 1;
			}else if(mixmod->G == 2){
				ej_case = 2;
			}else if(mixmod->G == maxgroups-1){
				ej_case = 3;
			}else{
				ej_case = 4;
			}
		
		
			switch(ej_case)
			{
				case 0:
					pr_ej_G = 1.;
					pr_ej_Gp1 = .5;
					pr_ej_Gm1 = 0.;
				break;
			
				case 1:
					pr_ej_G = 0.;
					pr_ej_Gp1 = 0.;
					pr_ej_Gm1 = .5;
				break;
			
				case 2:
					pr_ej_G = .5;
					pr_ej_Gp1 = .5;
					pr_ej_Gm1 = 1.;
				break;
			
				case 3:
					pr_ej_G = 0.5;
					pr_ej_Gp1 = 0.;
					pr_ej_Gm1 = 0.5;
				break;
			
				case 4:
					pr_ej_G = 0.5;
					pr_ej_Gp1 = 0.5;
					pr_ej_Gm1 = 0.5;
				break;
			}
		
		
			if(gsl_rng_uniform(r) < pr_ej_G){		
				update_allocations_with_ejection_move(mixmod,r,&(results->accepted_eject),&(results->proposed_eject),pr_ej_G,pr_ej_Gp1);
			}else{
				update_allocations_with_absorb_move(mixmod,r,&(results->accepted_absorb),&(results->proposed_absorb),pr_ej_G,pr_ej_Gm1);
			}
		
		
		}
		
		if(selectVariables){
			j = gsl_rng_uniform_int(r,mixmod->d);
			update_model_by_variable_include_exclude(mixmod,r,&(results->accepted_include_exclude_variable),&(results->proposed_include_exclude_variable),j);
			if(mixmod->hprior_model){
				//update the prior probaility variable inclusion using hyperprior
				j = 0;
				for(i=0;i<mixmod->d;i++) j += mixmod->varindicator[i];
				mixmod->prior_prob_variable_include = gsl_ran_beta (r,(double)j + mixmod->hprior_model_a0, (double)(mixmod->d-j) + mixmod->hprior_model_b0);
			}
		}
		
		
		if(l > num_burnin-1 && (l+1-num_burnin)%thin_by == 0){
		
			itmod = ((l+1-num_burnin)/thin_by)-1;
		
			if(selectVariables){
			
				if(!writeToFile){
					for(j=0;j<mixmod->d;j++){
						variable_inclusion_indicator[ itmod + j*gap ] = mixmod->varindicator[j];//results->variable_indicator[i][j];
					}
				}
			
				for(i=0;i<mixmod->d;i++){
				 	if(mixmod->varindicator[i]) results->variable_prob_inclusion[i] += 1.;
				}
			}
			
			results->ngroups[itmod] = mixmod->G;
			
			n_groups[itmod] = mixmod->G;
			
			prior_include[itmod] = mixmod->prior_prob_variable_include;
		
			if(!writeToFile)
			{	
				/*if(selectVariables){
					for(i=0;i<mixmod->d;i++){
						if(mixmod->varindicator[i]){
							results->variable_indicator[itmod][i] = 1;
						}else{
							results->variable_indicator[itmod][i] = 0;
						}
					}
			
				}*/
			
				/*store in results*/
				/*for(i=0;i<mixmod->n;i++){
					results->memberships[itmod][i] = mixmod->z[i];
				}*/
				
				for(j=0;j<mixmod->n;j++){
					group_memberships[itmod + j*gap ] = mixmod->z[j];
				}
				
			
			}
			else
			{
				//write the results to file instead
				if(selectVariables){
					for(i=0;i<mixmod->d-1;i++){
						fprintf(fp_varindicator,"%d,",mixmod->varindicator[i]);
					}
					fprintf(fp_varindicator,"%d\n",mixmod->varindicator[mixmod->d-1]);
				
				}
			
				fprintf(fp_ngroups,"%d\n",mixmod->G);
				for(i=0;i<mixmod->n-1;i++){
					fprintf(fp_memberships,"%d,",mixmod->z[i]);
				}
				fprintf(fp_memberships,"%d\n",mixmod->z[mixmod->n-1]);
				fprintf(fp_pp_include,"%lf\n",mixmod->prior_prob_variable_include);
			}
		}
		
		
		/*store the value of the log posterior here- full value (incl prior for no. components)*/
		if(!writeToFile){
			//results->log_posterior[l] = get_full_log_posterior(mixmod);
			log_joint_posterior[l] = get_full_log_posterior(mixmod);
		}else{
			fprintf(fp_log_posterior,"%.10f\n",get_full_log_posterior(mixmod));
		}
		
	
	}
	
	
	if(selectVariables){
		for(i=0;i<mixmod->d;i++){
			results->variable_prob_inclusion[i] /= ((num_iteration-num_burnin)/thin_by);
		}
	}
	

	//fclose(fpcheck);

	/*write code here to relabel the output from the MC algorithm and block*/


	/*write code here to compute the MAP_memberships*/
	
	
	/*free the random number generator*/
	gsl_rng_free(r);

	return(results);

}


void do_mixmod_analysis_not_collapsed(struct mix_mod *mixmod,int num_iteration,int num_burnin,int thin_by,int writeToFile,FILE *fp_memberships,FILE *fp_varindicator,FILE *fp_log_posterior,int *group_memberships, double *group_weights, double *variable_probabilities, double *log_joint_posterior)
{

	//this is the non-collapsed form of the model which uses Gibbs updates for all unknowns...
	// in this model there is no search for the number of groups, and no variable selection moves
	
	int i,j,k,l,c,p,idx,g_new,ind,itmod,*order;
	
	double *w,s,m;
	w = calloc(mixmod->G,sizeof(double));
	
	order = calloc(mixmod->n,sizeof(int));
	
	double **v; 
	v = calloc(mixmod->d,sizeof(double *));
	for(i=0;i<mixmod->d;i++) v[i] = calloc(mixmod->ncat[i],sizeof(double));
	
	int gap = (num_iteration - num_burnin)/(thin_by), gap_;
	
	//struct results res,*results;
	//results = &res;
	
	const gsl_rng_type *T;
	gsl_rng *r;
	
	gsl_rng_env_setup();
 
  	T = gsl_rng_default;
  	r = gsl_rng_alloc(T);
  	
  	/*seed the random number generator from system time*/
  	gsl_rng_set(r,(int)time(NULL));
  	
  	//Rprintf("\nThe value of beta = %.5f ",mixmod->beta);
	
	for(l=0;l<num_iteration;l++){
	
		//sample the weights
		s = 0.;
		for(i=0;i<mixmod->G;i++){
			w[i] = gsl_ran_gamma(r,mixmod->components[i]->n_g + mixmod->alpha,1.);
			s += w[i];
		}
		for(i=0;i<mixmod->G;i++) mixmod->weights[i] = w[i]/s;
		
		//sample the variable probabilities
		for(i=0;i<mixmod->G;i++){
			for(j=0;j<mixmod->d;j++){
				s = 0;
				for(k=0;k<mixmod->ncat[j];k++){
					 v[j][k] = gsl_ran_gamma(r,mixmod->components[i]->N[j][k]+mixmod->beta,1.);
					 s += v[j][k];
				}
				for(k=0;k<mixmod->ncat[j];k++) mixmod->components[i]->prob_variables[j][k] = v[j][k]/s;
				//Rprintf("\n value of s %.2f for variable j %d in group %d",s,j,i);
			}
		}
	
		//sample the memberships in a random order
		
		for(i=0;i<mixmod->n;i++){
			order[i] = i;
		}
		gsl_ran_shuffle(r,order,mixmod->n,sizeof(int));
		
		for(k=0;k<mixmod->n;k++){
			
			idx = order[k];
			
			for(i=0;i<mixmod->G;i++){
				w[i] = log(mixmod->weights[i]);
				for(j=0;j<mixmod->d;j++){
					c = mixmod->Y[j][idx];
					w[i] += log(mixmod->components[i]->prob_variables[j][c]);		
					//Rprintf("\n \t variable %d contrib %.2f",j,	mixmod->components[i]->prob_variables[j][c]);
				}
				//Rprintf("\nvalue %d is %.2f, weight = %.2f ",i,w[i],mixmod->weights[i]);
			}
			
			
			
			m = w[0];
			for(i=1;i<mixmod->G;i++){
				if(w[i]>m) m = w[i];
			}
			s = 0.;
			for(i=0;i<mixmod->G;i++){
				 w[i] -= m;
				 w[i] = exp(w[i]);
				 s += w[i];
			}
			for(i=0;i<mixmod->G;i++) w[i] /= s;
			
			g_new = sample_discrete(w,mixmod->G,r);
			
			if(g_new != mixmod->z[idx])
			{
				//take out of component counts in old and put into new
				for(j=0;j<mixmod->d;j++)
				{
					c = mixmod->Y[j][idx];
					mixmod->components[ mixmod->z[idx] ]->N[j][c] -= 1;
					mixmod->components[ g_new ]->N[j][c] += 1;
				}
				mixmod->z[idx] = g_new;
				mixmod->components[ mixmod->z[idx] ]->n_g -= 1;
				mixmod->components[ g_new ]->n_g += 1;
			}
			
		}
		
		p = 0;
		
		//storage of results
		if(l > num_burnin-1 && (l+1-num_burnin)%thin_by == 0){
		
			itmod = ((l+1-num_burnin)/thin_by)-1;
			
			if(!writeToFile)
			{	
				for(j=0;j<mixmod->n;j++){
					group_memberships[itmod + j*gap ] = mixmod->z[j];
				}		
				
				for(j=0;j<mixmod->d;j++){
					gap_ = p*mixmod->G*gap;
					for(i=0;i<mixmod->G;i++){
						for(k=0;k<mixmod->ncat[j];k++){
							variable_probabilities[ //long index expression
							
								gap_ + itmod*mixmod->ncat[j]*mixmod->G + i*mixmod->ncat[j] + k 
								
								] = mixmod->components[i]->prob_variables[j][k];
						}
					}
					p += mixmod->ncat[j];
				}
				
				for(i=0;i<mixmod->G;i++) group_weights[itmod*mixmod->G + i] = mixmod->weights[i];
					
			}
			else
			{
				//don't allow this for the moment
				
				//write the results to file instead
			
				//fprintf(fp_ngroups,"%d\n",mixmod->G);
				/*for(i=0;i<mixmod->n-1;i++){
					fprintf(fp_memberships,"%d,",mixmod->z[i]);
				}
				fprintf(fp_memberships,"%d\n",mixmod->z[mixmod->n-1]);*/
				
			}	
		
		}	
		
		if(!writeToFile){
			log_joint_posterior[l] = get_full_log_posterior_x2(mixmod);
		}else{
			//do nothing at moment
		}
		
	}

	free(w);
	for(i=0;i<mixmod->d;i++) free(v[i]);
	free(v);

	/*free the random number generator*/
	gsl_rng_free(r);
	
	return;

}





int write_out_results(struct results *results,int N,int datasize,int datadimension,int onlyGibbs,int fixedG,int selectVariables)
/*write results out to file*/
{

	int i,j,k,Gmax,*freqG;
	
	if(!onlyGibbs){
	
		/*print acceptance rate to screen*/
		Rprintf("\n The acceptance rate for metropolis move 1 was : %.10f \n",(double)results->accepted_m1/(double)results->proposed_m1);
		Rprintf("\n The acceptance rate for metropolis move 2 was: %.10f \n",(double)results->accepted_m2/(double)results->proposed_m2);
		Rprintf("\n The acceptance rate for metropolis move 3 was: %.10f \n",(double)results->accepted_m3/(double)results->proposed_m3);
	
	}
	
	if(!fixedG){
	
		Rprintf("\n The acceptance rate for ejections was: %.10f \n",(double)results->accepted_eject/(double)results->proposed_eject);
		Rprintf("\n The acceptance rate for absorb moves was: %.10f \n",(double)results->accepted_absorb/(double)results->proposed_absorb);
	
	
		/*count up frequencies of numbers of components*/
		k = N;//results->niterations-results->nburnin; /*no. of elements in vector*/
	
		Gmax = get_imax(results->ngroups,k);
	
		/*allocate a vector for counts*/
		freqG = calloc(Gmax,sizeof(int));
		for(i=0;i<k;i++){
			freqG[results->ngroups[i]-1] += 1;
		}
	
		/*print out*/
		Rprintf("\n\n\t -- Frequency in each number of components --\n\n\t G \t\t\t Posterior probability\n\n");
		for(i=0;i<Gmax;i++){
		Rprintf("\t %d \t\t\t %.5f \n",i+1,(double)freqG[i]/(double)(k));
		}
	
	
	
		/*for(i=0;i<N;i++){ with
			for(j=0;j<datasize-1;j++){
				fprintf(fp1,"%d,",results->memberships[i][j]);
			}
			fprintf(fp1,"%d\n",results->memberships[i][datasize-1]);
		}
	
		for(i=0;i<N;i++){
			fprintf(fp2,"%d\n",results->ngroups[i]);
		}*/

		free(freqG);
	
	}
	
	if(selectVariables){
	
		Rprintf("\n The acceptance rate for adding/removing variables was: %.10f \n",(double)results->accepted_include_exclude_variable/(double)results->proposed_include_exclude_variable);
		Rprintf("\n\nThe inclusion probability of each of the variables was\n\n");
		for(i=0;i<datadimension;i++){
			Rprintf("\nVariable %d \t\t\t %.5f",i+1,results->variable_prob_inclusion[i]);
		}
		Rprintf("\nNote that this calculation is based only on an empirical calculation\n using the MCMC output of occurances of a variable being in/out");
		

	}

	return(TRUE);
}


/*----------------------------------------computation of marginal posterior quantities--------------------------------------------*/


double **compute_marginal_posterior_probabilities_class_membership(struct mix_mod *mixmod,struct results *input,int n_sample,int n_groups)
{

	int i,ii,jj,g,j,s,z,n_var_in,*cat,zzz;
	double ***l,lpriorvariable,store_log_prob,store_log_prob_x,**marginal_probabilities,*x;
	
	/*l is a triple indexed array 
		-index 1 corresponds to sample number
		-index 2 corresponds to item number
		-index 3 corresponds to group number
	 */
	
	l = calloc(n_sample,sizeof(double **));
	for(i=0;i<n_sample;i++){
		l[i] = calloc(mixmod->n,sizeof(double *));
		for(j=0;j<mixmod->n;j++){
			l[i][j] = calloc(mixmod->G,sizeof(double));
		}
	}
	
	cat = calloc(mixmod->d,sizeof(int));
	
	marginal_probabilities = calloc(mixmod->n,sizeof(double *));
	for(i=0;i<mixmod->n;i++){
		marginal_probabilities[i] = calloc(mixmod->G,sizeof(double));
	}
	
	x = calloc(n_sample,sizeof(double));
	
	/*processing each separate sample is the hard part, so this will be the first loop*/
	
	
	for(s=0;s<n_sample;s++){
		
		/*do a check to see if all in one group!*/
		
		for(ii=0;ii<mixmod->n;ii++){
			mixmod->z[ii] = input->memberships[s][ii];
		}
			
		for(jj=0;jj<mixmod->d;jj++){
			mixmod->varindicator[jj] = input->variable_indicator[s][jj];
			}
		
		n_var_in = 0;
		for(ii=0;ii<mixmod->d;ii++){
			n_var_in += mixmod->varindicator[ii];
			}
			
		lpriorvariable = l_prior_variable_include(n_var_in,mixmod);		
		
		
		recompute_sufficient_statistics_for_components(mixmod);
		
		recompute_marginal_likelihood_undiscriminating_variables(mixmod->undiscriminating,mixmod);
		
			
		for(g=0;g<mixmod->G;g++){
			recompute_marginal_likelihood_component(mixmod->components[g],mixmod);
		}
			
		for(i=0;i<mixmod->n;i++){
			
			z = mixmod->z[i]; 
			
			store_log_prob_x = mixmod->components[z]->log_prob;
			
			for(j=0;j<mixmod->d;j++){
				cat[j] = mixmod->Y[j][i];
			}
			
			
			/*take i out of it's current component z*/
			
			mixmod->components[z]->n_g -= 1;
			for(j=0;j<mixmod->d;j++){
				mixmod->components[z]->N[j][ cat[j] ] -= 1;		
			}	
			
			recompute_marginal_likelihood_component(mixmod->components[z],mixmod);
			
			//if((i==0||i==2) && s<2) Rprintf("\n fl2: llmarginal = %.10f ",mixmod->components[z]->log_prob);
			
			/*now cycle through each of the components putting i in it, and computing the quantities*/
			
			for(g=0;g<mixmod->G;g++){
			
				//if(s==0) Rprintf("\n g == %d ", g);
			
				store_log_prob = mixmod->components[g]->log_prob;
				
				mixmod->components[g]->n_g += 1;
				
				for(j=0;j<mixmod->d;j++){
					mixmod->components[g]->N[j][ cat[j] ] += 1;
				}
				
				recompute_marginal_likelihood_component(mixmod->components[g],mixmod);
				
				
				/*now compute the sum for when item i is placed in component g for sample s*/
				
				l[s][i][g] = lpriorvariable + mixmod->undiscriminating->log_prob; 
			
				for(ii=0;ii<mixmod->G;ii++){
					l[s][i][g] += mixmod->components[ii]->log_prob;	
				}
				
				/*if(i==0 && g==0){
					Rprintf("\n%.10f  ::  ",l[s][i][g]);
					for(jj=0;jj<mixmod->d;jj++) Rprintf("%d ",input->variable_indicator[s][jj]);
					Rprintf(" ::  undis %.5f",mixmod->undiscriminating->log_prob);
					Rprintf("\n :: component counts -> ");
					for(jj=0;jj<mixmod->G;jj++) Rprintf(" component %d, %d :",jj,mixmod->components[jj]->n_g);
				}*/
				
				mixmod->components[g]->n_g -= 1;
				
				for(j=0;j<mixmod->d;j++){
					mixmod->components[g]->N[j][ cat[j] ] -= 1;
				}
				
				mixmod->components[g]->log_prob = store_log_prob;
				
				//recompute_marginal_likelihood_component(mixmod->components[g],mixmod);
			
			}	
			

			/*now make sure to replace everything that was changed*/
				
			mixmod->components[z]->n_g += 1;
			for(j=0;j<mixmod->d;j++){
				mixmod->components[z]->N[j][ cat[j] ] += 1;
			}
			
			mixmod->components[z]->log_prob = store_log_prob_x;
			
		}
			
	}
	
	/*all quantities computed for all samples, gather together to compute marginal probabilities*/
	
	/*cycle through samples and groups*/
	
	double max,mprob,*M,maxM,norm_const;
	
	M = calloc(mixmod->G,sizeof(double));
	
	for(i=0;i<mixmod->n;i++){
	
		for(g=0;g<mixmod->G;g++){
		
			for(s=0;s<n_sample;s++){
				x[s] = l[s][i][g];
				/*if(i==0 && g==0){
					Rprintf("\n%.10f  ::",x[s]);
					for(jj=0;jj<mixmod->d;jj++) Rprintf("%d   ",input->variable_indicator[s][jj]);
				}*/
			}
			
			/*find max for stability when exponentiating*/
			max = x[0];
			j=1;
			while(j<n_sample){
				if(x[j]>max) max = x[j];
				j++;
			}
			
			M[g] = max;
			
			for(s=0;s<n_sample;s++){
				x[s] -= max;
				x[s] = exp(x[s]);
			}
			
			/*gather sum*/
			mprob = 0.;
			
			for(s=0;s<n_sample;s++)
				mprob += x[s];
			
			marginal_probabilities[i][g] = mprob;
			
			
		}
		
			/*if(i<mixmod->n){
				Rprintf("\n i = %d, marginal probs are : ",i);
				for(g=0;g<mixmod->G;g++) Rprintf("   %lf",marginal_probabilities[i][g]);	
				Rprintf("\n max are : ");
				for(g=0;g<mixmod->G;g++) Rprintf("   %.20f",M[g]);
			}*/
		
		
		//for(i=0;i<mixmod->n;i++){
		for(g=0;g<mixmod->G;g++){
			//Rprintf(" %.5f  ",log(marginal_probabilities[i][g])+M[g] );
		}
			//Rprintf("\n");
		//}
		
		/*if(i==0||i==2){
				Rprintf("\n");
				for(zzz=0;zzz<mixmod->G;zzz++) Rprintf(" %.5f and max = %.10f ",marginal_probabilities[i][zzz],M[zzz]);
			}*/
		
		/*now need to normalize over the G groups--use exp max trick for numerical stability*/
		
		/*get max value of M vec*/
		
		maxM = M[0];
		g=1;
		
		while(g<mixmod->G){
			if(M[g]>maxM)
				maxM = M[g];
			g++;
		}
		
		norm_const = 0.;
		for(g=0;g<mixmod->G;g++){
			M[g] -= maxM;
			M[g] = exp(M[g]);
			marginal_probabilities[i][g] *= M[g];
			norm_const += marginal_probabilities[i][g];
		}
		
		
		for(g=0;g<mixmod->G;g++)
			marginal_probabilities[i][g] /= norm_const;
	
	}
	
	for(s=0;s<n_sample;s++){
		for(i=0;i<mixmod->n;i++){
			free(l[s][i]);
		}
		free(l[s]);
	}
	free(l);
	free(x);
	free(M);
	free(cat);
	
	
	return(marginal_probabilities);

}


/*double **compute_marginal_posterior_probabilities_class_membership_new(struct mix_mod *mixmod,struct results *input,int n_sample,int n_groups)
{













}*/





double *compute_marginal_posterior_probabilities_variable_inclusion(struct mix_mod *mixmod,struct results *input,int n_sample,int n_groups)
{
	
	int i,ii,jj,g,j,s,z,n_var_in,*cat;
	double ***l,lpriorvariable,store_varinc,**marginal_probability_inclusion,*x;
	
	/*l is a triple indexed array
		-index 1 is the sample
		-index 2 is the variable 
		-index 3 is the quantity for variable in/out 
	*/
	
	l = calloc(n_sample,sizeof(double **));
	for(i=0;i<n_sample;i++){
		l[i] = calloc(mixmod->d,sizeof(double *));
		for(j=0;j<mixmod->d;j++){
			l[i][j] = calloc(2,sizeof(double));
		}
	}
	
	cat = calloc(mixmod->d,sizeof(int));
	
	marginal_probability_inclusion = calloc(mixmod->d,sizeof(double *));
	for(i=0;i<mixmod->d;i++){
		marginal_probability_inclusion[i] = calloc(2,sizeof(double));
	}
	
	x = calloc(n_sample,sizeof(double));
	
	for(s=0;s<n_sample;s++){
	
		/*cycle through each of the samples to compute quantities*/
			
		for(ii=0;ii<mixmod->n;ii++)
			mixmod->z[ii] = input->memberships[s][ii];
			
		for(jj=0;jj<mixmod->d;jj++)
			mixmod->varindicator[jj] = input->variable_indicator[s][jj];
		
		recompute_sufficient_statistics_for_components(mixmod);
		
		//recompute_marginal_likelihood_undiscriminating_variables(mixmod->undiscriminating,mixmod);
			
		/*for(g=0;g<mixmod->G;g++){
			recompute_marginal_likelihood_component(mixmod->components[g],mixmod);
		}*/
		
		
		for(j=0;j<mixmod->d;j++){
		
			store_varinc = mixmod->varindicator[j];
		
			for(ii=0;ii<2;ii++){
			
				mixmod->varindicator[j] = ii; /*first iter of loop does exclusion, second inclusion*/
				
				n_var_in = 0;
				for(jj=0;jj<mixmod->d;jj++){
					n_var_in += mixmod->varindicator[jj];
				}		
				
				lpriorvariable = l_prior_variable_include(n_var_in,mixmod);	
				
				recompute_marginal_likelihood_undiscriminating_variables(mixmod->undiscriminating,mixmod);
				
				l[s][j][ii] = mixmod->undiscriminating->log_prob + lpriorvariable;
				
				for(g=0;g<mixmod->G;g++){
					recompute_marginal_likelihood_component(mixmod->components[g],mixmod);
					l[s][j][ii] += mixmod->components[g]->log_prob;
				}
				
			}
			
			mixmod->varindicator[j] = store_varinc;
		
		}		
	
	
	}
	
	
	double max,mprob,*M,maxM,norm_const;
	
	M = calloc(2,sizeof(double));		
	
	for(j=0;j<mixmod->d;j++){
	
		for(ii=0;ii<2;ii++){
		
			for(s=0;s<n_sample;s++){
				x[s] = l[s][j][ii];
			}
		
			max = x[0];
			jj=1;
			while(jj<n_sample){
				if(x[jj]>max)
					max = x[jj];
				jj++;
			}
			
			M[ii] = max;
			
			mprob=0.;
			
			for(s=0;s<n_sample;s++){
				x[s] -= max;
				mprob += x[s];
			}
			
			marginal_probability_inclusion[j][ii] = mprob;
			
		}
		
		/*now get the max of the M vector*/
		
		maxM = ( M[0] > M[1] ) ? M[0] : M[1];
		
		norm_const = 0.;
		for(ii=0;ii<2;ii++){
			M[ii] -= maxM;
			marginal_probability_inclusion[j][ii] *= exp(M[ii]);
			norm_const += marginal_probability_inclusion[j][ii];
		}
		
		//Rprintf("\n%.10f",norm_const);
		
		for(ii=0;ii<2;ii++)
			marginal_probability_inclusion[j][ii] /= norm_const;
		
	}
	
	double *prob_inclusion = calloc(mixmod->d,sizeof(double));
	
	for(j=0;j<mixmod->d;j++){
		prob_inclusion[j] = marginal_probability_inclusion[j][1];
	}

	for(s=0;s<n_sample;s++){
		for(i=0;i<mixmod->d;i++){
			free(l[s][i]);
		}
		free(l[s]);
	}
	free(l);
	free(x);
	free(cat);
	free(M);
	for(j=0;j<mixmod->d;j++){
		free(marginal_probability_inclusion[j]);
	}
	free(marginal_probability_inclusion);

	return(prob_inclusion);

}

void compute_marginal_posterior_probabilities_new_observation(int *ynew,struct mix_mod *mixmod,struct results *input,int n_sample,int n_groups,double *probs)
{

	int i,ii,jj,g,j,s,z,n_var_in,*cat;
	double **l,w,lpriorvariable,store_varinc,*marginal_probability_class,*x;
	
	/*l is a array
		-index 1 is the sample
		-index 2 is the group/class 
	*/
	
	l = calloc(n_sample,sizeof(double *));
	for(i=0;i<n_sample;i++){
		l[i] = calloc(n_groups,sizeof(double));
	}
	
	cat = calloc(mixmod->d,sizeof(int));
	
	marginal_probability_class = calloc(n_groups,sizeof(double));
	
	x = calloc(n_sample,sizeof(double));
	
	for(s=0;s<n_sample;s++){
	
		/*cycle through each of the samples to compute quantities*/
			
		for(ii=0;ii<mixmod->n;ii++)
			mixmod->z[ii] = input->memberships[s][ii];
			
		for(jj=0;jj<mixmod->d;jj++)
			mixmod->varindicator[jj] = input->variable_indicator[s][jj];

		n_var_in = 0;
		for(jj=0;jj<mixmod->d;jj++){
			n_var_in += mixmod->varindicator[jj];
		}		
			
		lpriorvariable = l_prior_variable_include(n_var_in,mixmod);				
		
		recompute_sufficient_statistics_for_components(mixmod);
		
		recompute_marginal_likelihood_undiscriminating_variables(mixmod->undiscriminating,mixmod);
		
		for(g=0;g<n_groups;g++){
			recompute_marginal_likelihood_component(mixmod->components[g],mixmod);
		}
		
		for(g=0;g<n_groups;g++){
		
			/*place in each group and compute probability*/
			
			w = compute_log_marginal_likelihood_with_inclusion_in_component(ynew,mixmod->components[g],mixmod);
			
			l[s][g] = w + mixmod->undiscriminating->log_prob + lpriorvariable;
		
			for(ii=0;ii<n_groups;ii++){
				if(!(ii==g)){
					l[s][g] += mixmod->components[ii]->log_prob;
				}
			}
		
		}
	
	}

	double max,mprob,*M,maxM,norm_const;
	
	M = calloc(n_groups,sizeof(double));
	
	for(g=0;g<n_groups;g++){
	
		for(s=0;s<n_sample;s++){
			x[s] = l[s][g];
		}
		
		/*find max*/
		max = x[0];
		j=1;
		while(j<n_sample){
			if(x[j]>max)
				max = x[j];
			j++;
		}
		
		M[g] = max;
		
		marginal_probability_class[g] = 0.;
		
		for(s=0;s<n_groups;s++){
			x[s] -= max;
			marginal_probability_class[g] += exp(x[s]);
		}
		
	}
	
	/*max of M*/
	
	maxM = M[0];
	j=1;
	while(j<n_groups){
		if(M[j]>maxM)
			maxM = M[j];
		j++;
	}
	
	norm_const = 0.;
	for(g=0;g<n_groups;g++){
		M[g] -= maxM;
		marginal_probability_class[g] *= exp(M[g]);
		norm_const += marginal_probability_class[g];
	}
	
	for(g=0;g<n_groups;g++){
		marginal_probability_class[g] /= norm_const;
		probs[g] = marginal_probability_class[g];
		}


	for(i=0;i<n_sample;i++){
		free(l[i]);
	}
	free(l);
	free(cat);
	free(x);
	free(M);
	free(marginal_probability_class);
	
	return;

}


void compute_post_hoc_parameter_estimates_for_variable(struct mix_mod *mixmod,struct results *input,int n_sample,int n_groups,int variable,double **Estimate,double **SE_Estimate)
{

	int i,j,g,k,z,c,s,*items,**counts,*ng;
	double ***expected,***variance;
	
	ng = calloc(mixmod->G,sizeof(int));
	
	expected = calloc(n_sample,sizeof(double **));
	variance = calloc(n_sample,sizeof(double **));
	for(i=0;i<n_sample;i++){
		expected[i] = calloc(mixmod->G,sizeof(double *));
		variance[i] = calloc(mixmod->G,sizeof(double *));
		for(j=0;j<mixmod->G;j++){
			expected[i][j] = calloc(mixmod->ncat[variable],sizeof(double));
			variance[i][j] = calloc(mixmod->ncat[variable],sizeof(double));
		}
	}
	
	items = calloc(mixmod->n,sizeof(int));
	counts = calloc(mixmod->G,sizeof(int *));
	for(g=0;g<mixmod->G;g++){
		counts[g] = calloc(mixmod->ncat[variable],sizeof(int));
	}
	
	for(s=0;s<n_sample;s++){
	
		for(g=0;g<mixmod->G;g++){
			for(j=0;j<mixmod->ncat[variable];j++){
				counts[g][j] = 0;
			}
			ng[g] = 0;
		}
	
		for(i=0;i<mixmod->n;i++){
		
			z = input->memberships[s][i];
			
			c = mixmod->Yobs[i][variable];
			
			counts[z][c] += 1;
			
			ng[z] += 1;
		
		}
		
		for(g=0;g<mixmod->G;g++){
			for(j=0;j<mixmod->ncat[variable];j++){
				expected[s][g][j] = (counts[g][j] + mixmod->beta)/(ng[g]+(mixmod->ncat[variable]-1.)*mixmod->beta);
				variance[s][g][j] = (counts[g][j]+mixmod->beta)*(ng[g] - counts[g][j] + mixmod->ncat[variable]*mixmod->beta)/(pow(ng[g] + (mixmod->ncat[variable]-1.)*mixmod->beta,2.)*(ng[g]+(mixmod->ncat[variable]-1.)*mixmod->beta + 1.));
				Estimate[g][j] += expected[s][g][j];
				SE_Estimate[g][j] += variance[s][g][j];
			}
		}
		
		
		
	}
	
	
	/*now begin to do the estimates, cycling through samples...*/
	
	for(g=0;g<mixmod->G;g++){
		for(j=0;j<mixmod->ncat[variable];j++){
			Estimate[g][j] /= n_sample;
			SE_Estimate[g][j] /= n_sample;
		}
	}
	
	for(s=0;s<n_sample;s++){
		for(g=0;g<mixmod->G;g++){
			for(j=0;j<mixmod->ncat[variable];j++)
					expected[s][g][j] -= Estimate[g][j];		
		}
	}
	
	double *se;
	se = calloc(mixmod->ncat[variable],sizeof(double));
	
	for(g=0;g<mixmod->G;g++){
	
		for(j=0;j<mixmod->ncat[variable];j++){
			se[j] = 0.;
		}
		
		for(s=0;s<n_sample;s++){
			
			for(j=0;j<mixmod->ncat[variable];j++)
				se[j] += pow(expected[s][g][j],2.);
		
		}
		
		for(j=0;j<mixmod->ncat[variable];j++){
			se[j] /= (n_sample - 1.);
			SE_Estimate[g][j] += se[j];
			SE_Estimate[g][j] = sqrt(SE_Estimate[g][j]);
		}
		
	}	
	
	
	for(i=0;i<n_sample;i++){
		for(j=0;j<mixmod->G;j++){
			free(expected[i][j]);
			free(variance[i][j]);
		}
		free(expected[i]);
		free(variance[i]);
	}

	free(expected);
	free(variance);
	
	for(i=0;i<mixmod->G;i++)
		free(counts[i]);
	
	free(items);
	free(counts);
	free(se);

	return;

}

/*void compute_post_hoc_parameter_estimates_for_class_probabilities(struct mix_mod *mixmod,struct results *input,int n_sample,int n_groups,int variable,double *Estimate,double *SE_Estimate)
{

	int i,j,k,s,*counts;
	double **expected;
	
	counts = calloc(mixmod->G,sizeof(int));
	expected = calloc(n_sample,sizeof(double *));
	for(i=0;i<n_sample;i++){
		expected[i] = calloc(mixmod->G,sizeof(double));
	}
	

	for(s=0;s<n_sample;s++){
	
		for(g=0;g<mixmod->G;g++){
			counts[g] = 0;
		}
	
		for(i=0;i<mixmod->n;i++){
		
			z = input->memberships[s][i];
			
			counts[z] += 1;
		
		}
		
		for(g=0;g<mixmod->G;g++){
			expected[s][g] = (counts[g]+mixmod->alpha)/(mixmod->n + mixmod->G*mixmod->alpha);
			Estimate[g] += expected[s][g];
			SE_Estimate[g] += (counts[g] + mixmod->alpha)*(mixmod->n - counts[g] + (mixmod->G - 1.)*mixmod->alpha)/(pow(mixmod->n + mixmod->G*mixmod->alpha,2.)*(mixmod->n + mixmod->G*mixmod->alpha + 1.));
		}
		
	}
	
	for(g=0;g<mixmod->G;g++){
		Estimate[g] /= n_sample;
		SE_Estimate[g] /= n_sample;
	}
	
	for(s=0;s<n_sample;s++){
		for(g=0;g<mixmod->G;g++){
			expected[s][g] -= Estimate[g];
			SE_Estimate += pow(expected[s][g],2.)/(n_sample-1.);
		}
	}
	
	
	for(g=0;g<mixmod->G;g++){
		SE_Estimate[g] = sqrt(SE_Estimate[g]);
	}


	free(counts);
	free(expected);
	
	return;

}*/


void recompute_sufficient_statistics_for_components(struct mix_mod *mixmod)
{

	int i,j,k;
	
	/*undiscriminating variables*/
	
	
	
	/*discriminating variables*/
	
	for(k=0;k<mixmod->G;k++){	
		/*reset*/
		for(j=0;j<mixmod->d;j++){
			for(i=0;i<mixmod->ncat[j];i++){
				mixmod->components[k]->N[j][i] = 0;
				mixmod->undiscriminating->N[j][i] = 0;
			}
		}
		mixmod->components[k]->n_g = 0;
	}
	
	int z;
	
	for(i=0;i<mixmod->n;i++){
	
		z = mixmod->z[i];	
		
		mixmod->components[ z ]->n_g += 1;
		
		for(j=0;j<mixmod->d;j++){
			mixmod->components[ z ]->N[j][ mixmod->Y[j][i] ] += 1;
			mixmod->undiscriminating->N[j][ mixmod->Y[j][i] ] += 1;
		}
	
	
	}
	
	return;
}



